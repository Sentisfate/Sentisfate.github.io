<!DOCTYPE html>
<html><head>
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="referrer" content="no-referrer" />
   
  <meta name="author" content="gisculibur">
  

   
  
  
  
  
  
  
  <meta name="keywords"
    content="theme,kagome">
  

  

  <meta name="generator" content="Hugo 0.115.2">


  
  
  
  
  <title>WEB HTML CSS JS 🌟 GIS咖喱棒</title>

  <meta property="og:title" content="WEB HTML CSS JS" />
<meta property="og:description" content="HTML 概念 超文本标记语言，主要用于描述一个页面。 操作思想 网页中有很多数据，不同的数据可能需要不同的展示效果，用标签来包裹数据，再通过修改标签的属" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Sentisfate.github.io/docs/klr3a3/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2022-05-25T13:13:41+00:00" />
<meta property="article:modified_time" content="2023-02-16T02:18:35+00:00" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="WEB HTML CSS JS"/>
<meta name="twitter:description" content="HTML 概念 超文本标记语言，主要用于描述一个页面。 操作思想 网页中有很多数据，不同的数据可能需要不同的展示效果，用标签来包裹数据，再通过修改标签的属"/>


  
  
  
  
  <link rel="stylesheet" href="https://Sentisfate.github.io/assets/css/style.min.a9eba8a87a1f5444669cfe92317af83504187100f2529f484b2eeaff89777b86.css" integrity="sha256-qeuoqHofVERmnP6SMXr4NQQYcQDyUp9ISy7q/4l3e4Y=">

  <script src="https://Sentisfate.github.io/assets/js/main.min.182da266209851bc7c828aa7377f98f914e1e76c8decdd53a6cbe9bffea92cde.js" integrity="sha256-GC2iZiCYUbx8goqnN3&#43;Y&#43;RTh52yN7N1Tpsvpv/6pLN4="></script>

  </head><body><header class="header-container layout-block layout-padding">
  <div class="header-inner content-padding-large soft-size--large soft-style--box">
    <div class="header-logo">
      <a href="https://Sentisfate.github.io"><h1>GIS咖喱棒</h1></a>
    </div>
    <nav class="header-nav">
      <div class="header-nav--btn">
        <div class="btn-item"></div>
        <div class="btn-item"></div>
        <div class="btn-item"></div>
      </div>
      <div class="header-nav--list">
        <div>
          
          <a class="list-item soft-size--small soft-style--hover soft-style--active" href="/" title="GIS咖喱棒">主页</a>
          
          <a class="list-item soft-size--small soft-style--hover soft-style--active" href="/docs/" title="Docs">笔记</a>
          
          <a class="list-item soft-size--small soft-style--hover soft-style--active" href="/categories/" title="Categories">分类</a>
          
          <a class="list-item soft-size--small soft-style--hover soft-style--active" href="/tags/" title="Tags">标签</a>
          
        </div>
      </div>
    </nav>
  </div>
</header><main id="content">
    

    <div class="single-container layout-block">
      <div class="article-info">
        <div class="article-header layout-padding">
          <div class="article-cover card-container content-padding-large soft-size--large soft-style--box ">

  <div class="card-cover">
    
  </div>

  <div class="card-text">
    <h1 class="card-text--title">WEB HTML CSS JS</h1>
    
      <p class="card-text--row">2022-05-25 13:13</p>
      
      
      

      
      
    
  </div>

</div>
        </div>

        <div class="article-content">
          <div class="markdown-body content-padding-large soft-size--large soft-style--box">
            <p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="html">HTML</h2>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="概念">概念</h3>
<pre tabindex="0"><code>超文本标记语言，主要用于描述一个页面。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="操作思想">操作思想</h3>
<pre tabindex="0"><code>网页中有很多数据，不同的数据可能需要不同的展示效果，用标签来包裹数据，再通过修改标签的属性来实现标签的标识的数据的样式的改变。

一个标签相当于一个容器，改变容器的属性值来改变数据的样式
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="特点">特点</h3>
<pre tabindex="0"><code>语法宽松
标签不区分大小写 （html5规范建议标签小写）
标签都是预定义好的，每个标签都有特殊的含义
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="语法">语法</h3>
<pre tabindex="0"><code>标签是由&#39;&lt;&gt;&#39; 括起来的关键字
&lt;h1&gt;
    标签体可以是普通文本也可以是其他标签
    &lt;table&gt;
        &lt;tr&gt;
        	&lt;td&gt;单元格内容&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/h1&gt;

属性 
	为元素提供更多信息，以键值对形式出现
注释
	&lt;!-- 注释内容--!&gt;
特殊字符
	&amp;nbsp；空格  &amp;lt；&lt;    &amp;gt：&gt;
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="标签分类">标签分类</h3>
<pre tabindex="0"><code>行标签
	是共占一行的，一行占不下才会换行显示，如font，span
	
块级标签
	不管上一行还有没有空间，都会另起一行，如h1-6标签，p，div（常用于布局）
	
行级标签块级标签没有一定的界限，在后面的css内容中是可以通过display这个属性来定义是行标签还是块标签
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="常用标签">常用标签</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>文档标签（结构标签）
</span></span><span style="display:flex;"><span>	&lt;<span style="color:#f92672">html</span>&gt;
</span></span><span style="display:flex;"><span>		&lt;<span style="color:#f92672">head</span>&gt;       ----html的头部
</span></span><span style="display:flex;"><span>            &lt;<span style="color:#f92672">title</span>&gt;&lt;/<span style="color:#f92672">title</span>&gt;
</span></span><span style="display:flex;"><span>        &lt;/<span style="color:#f92672">head</span>&gt; 
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">body</span>&gt;       ----标签正文
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        &lt;/<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>	&lt;/<span style="color:#f92672">html</span>&gt;
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="文本相关标签">文本相关标签</h3>
<pre tabindex="0"><code>标题标签 h1-6
段落标签  p
字体标签 font
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="格式相关标签">格式相关标签</h3>
<pre tabindex="0"><code>水平线 hr
换行 br
粗体 b strong
斜体 i  em
下划线 u
删除线 del
引用标签 q 在标签体周围加引号
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="列表相关标签">列表相关标签</h3>
<pre tabindex="0"><code>无序列表 ul（unorder list）
	属性：
		type： disc实心圆（默认），square 实心方块，circle 空心圆

有序列表 ol（order list） 
	属性：type，start
		type：列表的样式，1数字，A字母，I罗马字符
		start: 起始标记，如2的话就会从列表样式的第2个开始

ul和ol的列表项 li

自定义列表 dl
自定义列表项 dt
自定义列表项的描述dd 对dt的描述，如果有的话应紧跟在dt后面
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="行级标签">行级标签</h3>
<pre tabindex="0"><code>font 一般不用，因为样式修改基本上都在css里直接定义
span font能做到的span都能做到
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="块级标签">块级标签</h3>
<pre tabindex="0"><code>div
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="图片媒体标签">图片媒体标签</h3>
<pre tabindex="0"><code>图片标签 img
	属性：
		src：图片的路径，推荐使用相对路径
		./表示在当前文件的同一个文件夹下
		./目录名/文件
		../表示回到上一级目录
		alt：当图片加载不出来的时候会显示默认的内容
音频标签 audio
	属性：
		src：音频的路径
		controls：值为controls，能显示出播放键控制面板
视频标签：vedio
	属性：
		src：路径
		controls：显示播放的控制面板
		height： 控制播放页的高度
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="超链接标签">超链接标签</h3>
<pre tabindex="0"><code>标签名 a
	属性：
		herf：要跳转的页面
		target：定义页面的打开方式
			_blank: 空白页面
			_self:当前页面
超链接标签不仅可以跳转另一网站，还可以跳转本网站的网页，应用，当前网页的内容（通过id）等
注：音视频等应用格式写错的话浏览器不能识别，会直接下载，正确浏览器会先提示一下再下载
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="布局相关标签">布局相关标签</h3>
<pre tabindex="0"><code>语义化标签，没有任何样式，用于划分不同的区域，便于布局管理
header 页头
footer 页脚
nav 导航
main 主体
aside 侧边栏
section 区域
article 文章
是存在嵌套的，main里可以有header--main--...
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="布局标签div">布局标签div</h3>
<pre tabindex="0"><code>上面能实现的内容div都可以实现，只不过上面的更具有语义化
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="表单标签">表单标签</h3>
<pre tabindex="0"><code>form 表单
	属性：
		action：表单提交的地址，默认是提交到当前的页面
		method：表单提交的方式，有get和post两种
			get：把数据拼接到地址栏后面，相对不安全，只能提交少量的数据（是默认方式）
			post：将数据拼接到请求体中，相对安全，可以提交大量数据，用于上传和下载
input 输入标签，根据type属性值的不同表现为不同的样式，让用户输入或选择重要的属性
	属性：
		type：（默认文本框）
			text 文本框
			password 密码框
			radio 单选框
			checkbox 复选框
			file 文件框（用于选择上传文件）
			submit 提交按钮（提交页面数据）
			reset 重置按钮（恢复到页面刚打开时的效果）
			button 普通按钮
		checked：
			checked 单选和复选框的默认选中
		name：表单项想要提交到后台，必须要有name属性，同时name也会区分提交数据的，键值对name：value，此外name属性也能够对单选框和复选框进行分组
		value：对于单选和复选是指定选中的值，用于区分用户选择了那个值，默认都是on，用于其他的则是显示在控件上的文本内容；对于下拉选择框来说，是提交到后台的值，但是如果没有设置，则提交到后台的是option标签体的值。
select 下拉选择框
	属性：name，
option 下拉选择框的选项
	属性：selected =&#34;selected&#34; 设置默认选中项
textarea 文本域标签，写的时候要写在一行，尽量不换行，因为换行后表示标签体里有内容，其默认文字是直接使用的，优先级比占位符（placeholder）高。
label 标签 获得与其关联的控件的焦点
	属性：for 必须有
		for的属性值和与其相关联的标签的id一致。
button 见名知义，可以在标签里放置内容，文字，图片等，推荐使用。
	属性：
		type：submit，reset，button，menu
	在标签体里写文字能够实现button的文字
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="表格标签">表格标签</h3>
<pre tabindex="0"><code>table 表格标签
	属性：cellspacing 定义两个单元格之间的空间的大小，应用css的border-spacing属性
th (table head)表头 在td的基础上加粗和居中
tr (table row)表格中的行
td (table data)表格中的单元格

相关属性：
table
	width 宽度
	height 高度
	cellspacing 单元格之间的空白
	cellpadding 单元格内容与其边沿之间的空白
	border 边框
	rules 边框显示规则
tr
	align 内容对齐方式
td
	rowspan 跨行
	colspan 跨列
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="css">CSS</h2>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="概念-1">概念</h3>
<pre tabindex="0"><code>层叠样式表，用于设置样式
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="区别">区别</h3>
<pre tabindex="0"><code>1.css更加专业，可以实现html属性实现不了的效果
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="css的引入方式">css的引入方式</h3>
<pre tabindex="0"><code>1.行内样式：
	特点：耦合性强，不利于代码的分离，没有复用性
2.内部样式：
	使用style标签结合css选择器，给元素添加样式
	&lt;style&gt;
		选择器{
			属性：样式
		}
	&lt;/style&gt;
	特点：可在当前页面内复用。
3.外部样式
把css样式写在一个css文件里，然后在head标签里引用。
步骤：1）将样式写在一个css文件里
	 2）然后在head标签用link标签引用
特点：实现了代码和样式的分离，提高了复用性，可以在多个页面使用，统一了网站的风格。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="css三种引入的优先级">css三种引入的优先级</h3>
<pre tabindex="0"><code>行内样式优先级最高
外部样式与内部样式同级，谁在下面谁就优先级高，下面的会把上面的覆盖掉
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="css选择器分类">css选择器分类</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="作用">作用：</h4>
<pre tabindex="0"><code>选择指定的元素，设置样式或布局
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="基本分类">基本分类：</h4>
<pre tabindex="0"><code>1.元素选择器：
	标签名{
		属性：值;
		......
	}
2.id选择器：一般选择唯一的元素
	#id名{    /*-------注意id不能以数字开头，且是唯一的*/
		属性：值;
	}
3.类选择器：选择的是一类元素
	.class名{
		属性：值;
	}
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="三种优先级">三种优先级</h4>
<pre tabindex="0"><code>行内样式&gt;id选择器&gt;类选择器&gt;元素选择器
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="拓展分类">拓展分类</h4>
<pre tabindex="0"><code>1.并集选择器
	选择器1，选择器2，选择器3...{
		属性：值；
		...
	}
2.交集选择器
	选择器1.选择器2{
	
	}
3.后代选择器
	父选择器 后代选择器{
	
	}
4.子元素选择器
	父选择器&gt;子选择器{
	
	}
5.相邻兄弟选择器
	兄选择器+弟选择器{
		只会改变弟选择器
	}
6.属性选择器
	[属性=值]{
		改变的是具有该属性且该属性的值为特定值的元素的样式
	}
7.伪类 用于向某些选择器添加特殊效果
	选择器:伪类{
	
	}
	常用伪类有：
		锚伪类：
            hover：鼠标移动到上面显示样式
            visited，已访问的
            link：未访问的
            active：选定的
		first-child伪类 选择元素的第一个子元素。
		lang伪类，有能力为不同的语言定义特殊的规则，向有指定lang属性的元素添加样式
</code></pre><p>
  <p><img src="images/image-20220423143958987.png#id=NQJjb&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy" /></p>
</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="emmet语法">emmet语法</h3>
<pre tabindex="0"><code>本质是css选择器
语法规则：
1.生成普通标签 p  div  ...
2.生成标签加类名  .father  p.father...
3.生成标签+id  #id名  p#id名
4.生成指定标签+类名+属性 标签.class名#id名
5.生成带有子元素的标签 父&gt;子
6.生成内部文本 div{文本}
7.生成多个 div*4
生成带有指定属性的标签 标签名[属性2=值 属性1=值...]
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="常见属性">常见属性</h3>
<pre tabindex="0"><code>尺寸属性
	width：宽
	height：
背景属性
	background 背景（通用的，可以设置颜色图片等）
	background-color 背景颜色
	background-image 背景图片
文本属性
	color 颜色
字体属性
	font-size 字体大小
	font-family
	font-style
边框属性
	border 边框（可以设置边框的宽度，样式颜色）
盒子模型
	margin 外边距
	padding 内边距
	border 边框
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="字体相关属性">字体相关属性</h3>
<pre tabindex="0"><code>font-size 字体大小如： 40px
font-weight 字体粗细如 700相当于是bold加粗，默认是400normal
font-family 字体族，如宋体，楷体等
font-style 字体风格 默认normal无风格。
font 字体属性简写  style weight size family swsf（稍微舒服）
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="文本相关属性">文本相关属性</h3>
<pre tabindex="0"><code>color 设置文本的颜色
text-align 规定文本的水平对齐方式
text-decoration 规定文本的装饰效果，
	underline 定义下划线
	overline 定义上划线
	line-through 穿过文本下的一条线
	none 无样式
margin 设置左右外边距为auto，实现块元素的水平居中
text-indent 设置文本首行缩进，1em 相当于当前font-size的大小
line-height 设置行高，行高等于容器高时能使单行文本垂直居中。
	在网页精准布局的时候，会设置行高为1，来取消上下默认间距。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="背景相关属性">背景相关属性</h3>
<pre tabindex="0"><code>基本属性
	背景颜色
		background-color或者background
	背景图片
		background-image或者background
	背景平铺
		background-repeat
			repeat-x 默认是水平平铺的
			repeat-y 竖直平铺
			no-repeat 无
	背景位置
		background-position
			背景图片左上角在块（div）中的坐标，先是x方向，然后是y方向，如50px 50px 或者 center center 或者50% 50%左上角对齐为0%，右下角对齐为100%（这也是实现居中的一种方式）。
		background-size:设置背景图片的大小，可以适应容器的大小 如100%
背景速写
	background：color image repeat position
颜色取值
	1.关键字
	2.rgb
	3.rgba
	4#16进制
关于image与background的区别：
	1.img属于html的范畴，是页面骨架的一个部分，background-image是属于css的范畴，主要是起到一个装饰作用。
	2.img如果没有设置图片，其宽高为0*0，本质是一个行内块。
	3.使用div+background-image，显示图片，即使设置了背景图片，在不设置div高度的时候，其div的高为0，图片显示不出来
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="精灵图的应用">精灵图的应用</h4>
<pre tabindex="0"><code>场景
	将项目中多张小图片，合成一个大图片，这张大图片就是精灵��
优点
	减少服务器发送图片的次数，提高页面的加载速度
使用步骤
	1.创建一个盒子
	2.设置盒子的大小为图片的大小
	3.设置精灵图为背景图片
	4.将小图片左上角的坐标取负值，设置给图片的background-position属性
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="css三大特性">CSS三大特性</h3>
<pre tabindex="0"><code>1.层叠性：
	后写的样式会覆盖先写的样式（相同属性的会覆盖，不同属性的会叠加）。
2.继承性：
	子元素会继承父元素的相关属性，可以在一定程度上减少代码。一般继承的是文本，字体对齐方式等。
	应用场景：如直接给ul设置list-style能改变li的符号，给body设置字体，整个页面的字体也会改变
3.优先级
	不同选择器有不同的优先级，优先级高的覆盖低的样式。
	规律：继承&lt;元素选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;!important
	注意点：
		1.！important写在属性值的后面，分号的前面
		2.！important不能提升继承的优先级，只要是继承优先级最低
		3.实际开发中，不建议使用！important
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="盒子模型">盒子模型</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="行盒块盒分类">行盒块盒分类</h4>
<pre tabindex="0"><code>行级元素对应行盒
	共占一行，设置宽高没有效果，宽度由内容撑开
	
块级元素对应的就是块盒
	独占一行，设置宽高与效果，不设置的话，高度有内容撑开，宽度与父元素保持一致

互转 display属性
	行级转块级元素， display:block
	块转行， display:inline
	行内块， display:inline-block,可以设置宽高，共占一行。
行级元素当浏览器显示不下的时候，会换行。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="盒子模型的组成">盒子模型的组成</h3>
<pre tabindex="0"><code>border 边框
padding 内边距
margin 外边距
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="边框详解">边框详解</h3>
<pre tabindex="0"><code>分开写
	border-width
	border-style
	border-color
连写
	border:border-width border-style border-color
单独设某一方向的边框
	border-top/right/bottom/left: width style color  可以实现画三角形，设置透明色
圆角
	border-radius，圆角设置为盒子边长的一半时，可以实现画圆，左上，右上，右下，左下
	

设置边框会撑大盒子
盒子的宽度=左边框 + 内容的宽度 + 右边框 + 内边距
盒子的高度=上边框 + 内容的高度 + 下边框 + 内边距

解决方案
	计算多余的大小，手动的在内容中减去（手动内减）
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="内边距">内边距</h3>
<pre tabindex="0"><code>作用
	设置边框和内容区域的距离
赋值规律
	从上开始，顺时针赋值（上右下左）没有赋值看对面
只给某一方向设置
	padding-方位词：像素值
设置内边距也会撑大��子

应用：
	可以让两个或多个元素之间有固定间隙
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="盒子模型最终计算公式">盒子模型最终计算公式</h3>
<pre tabindex="0"><code>1.手动内减
	盒子的宽=内容区域的宽高+padding左+padding右+边框左+边框右
	盒子的高=内容区域的高+padding上+padding下+边框上+边框下

2.自动内减
	设置盒子的最终宽高为 width，height两属性，子设置padding和边框，最后用上属性box-sizing:border-box，此时内容的width和height会自动变为原设值-边框和内边距
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="盒子模型的特殊情况">盒子模型的特殊情况</h4>
<pre tabindex="0"><code>如果在父盒子里放了一个子盒子，子盒子的宽度没有设定，那么子盒子的宽度默认是父盒子的宽度，子盒子的内容区域会依据边框和内边距自动内减。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="外边距">外边距</h3>
<pre tabindex="0"><code>作用
	设置边框意外的，盒子与盒子之间的距离
取值规律
	从上开始，顺时针取值，没有看对面
给某一方向取值
	margin-top/right/bottom/left
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="外边距的正常情况">外边距的正常情况</h4>
<pre tabindex="0"><code>场景
	水平布局的盒子，左右外边距会显示正常，两个盒子的间距是左右外边距之和
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="外边距的特殊情况">外边距的特殊情况</h4>
<pre tabindex="0"><code>场景 
	垂直布局的盒子，上下外边距会是外边距较大的那个
避免就好，只给其中一个margin设置就好
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="外边距的塌陷上外边距">外边距的塌陷（上外边距）</h4>
<pre tabindex="0"><code>场景
	互相嵌套的块元素的盒子，子元素的margin-top会作用在父元素上，会导致父元素一起向下移动
解决方式
	1.给父元素设置border-top，或者padding-top，分隔父子元素的margin，或者父元素中有东西，也会分隔。
	2.给父元素设置overflow：hidden
	3.转成行内块元素
	4.设置浮动
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="清楚浏览器的默认样式">清楚浏览器的默认样式</h3>
<pre tabindex="0"><code>应用场景：浏览器会被部分设置默认的margin和padding，这些其实我们都不需要，一般在项目开始前就需要先清除这些标签的默认样式

如 body的默认margin为8
	p的默认上下margin
	ul默认上下margin和padding-left
	*{
		margin:0;
		padding:0;
	}
	或者选择要清除样式的标签
	a,p,...{
		margin:0;
		padding:0;
	}
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="伪元素">伪元素</h3>
<pre tabindex="0"><code>作用：
	一般在页面中的非主体内容可以使用伪元素。
区别
	元素：html设置的标签
	伪元素：css模拟出来的标签效果
	本质区别：在于是否创建了新的元素

种类
	::before 在父元素的第一个子元素前面加一个伪元素
	::after 在父元素的最后一个子元素后面加一个伪元素
	前面跟的是父元素,这是作用在父元素上的伪元素,但产生的是子元素.
注意点
	1.必须要设置content属性才能生效
	2.伪元素默认是行元素
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="伪类结构选择器">伪类结构选择器</h3>
<pre tabindex="0"><code>作用
	无需添加额外的属性，就可以根据元素在html中的结构关系来查找元素
区别
	普通选择择器，在html结构中是存在的，有标识的
	伪类选择器，在html结构中是不存在的，是逻辑上的关系来选择元素，没有标识的
	之前a标签的各种状态就是伪类选择器
语法
	选择一个
		:first-child  同辈的第一个元素
		:last-child  同辈的选择最后一个
		
	选择多个
		:nth-child(n) 同辈的选择第n个  
		:nth-last-child(n) 同辈的选择倒数第n个
		n关键字，从0开始，非负整数
		可以通过表达式 an+b来选择多个，an+b公式固定，不能写成b+an的形式，否则会认为是非法的，选择器无效
			偶数：2n even
			奇数：2n+1 odd
			前5个：-n+5  
			5个往后（不包括5）：n+6

优势：
	减少度html类选择器的依赖，有利于保持代码的整洁
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="标准流">标准流</h3>
<pre tabindex="0"><code>概念
	又称文档流，是浏览器在渲染显示网页内容的默认时采用的一套排版规则，规定了应该以何种方式排列元素。
常见规则
	块元素
		从上到下，独占一行，垂直布局
	行级元素
		从左到右，水平布局，只有空间不够才换行
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="浮动float">浮动float</h3>
<pre tabindex="0"><code>作用
	早期，图文混排
	现在，网页布局（块级元素水平布局）
语法
	left 向左浮动
	right 向右浮动
	none 默认值，无浮动

特点
	1.浮动的元素会脱离标准流，不在标准流中占用空间，相当于从地面飘向了天空。
	2.浮动的元素，比标准流级别高，会覆盖标准流中的排在要浮动元素后面的块元素。但是不会覆盖文本等行元素，或者行内块元素。
	3.下一个浮动元素会在上一个浮动元素后面进行左右浮动。
	4.浮动元素会受到上面元素的边界影响
	5.浮动元素会有特殊的显示效果
		块级元素浮动后，可以一行显示多个
		行级元素浮动后，可以设置宽高（不需要设置display：为inline-block或者block就可以设置宽高）
	关于行内块参与其中的浮动，参看条件3
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="清除浮动">清除浮动</h3>
<pre tabindex="0"><code>概念
	清除浮动带来的影响（子元素浮动了，就不能撑开标准流中父元素的高度，后面的元素就会上位）
原因
	子元素浮动后脱标不占位置
目的
	要让父元素有高度，从而不影响网页的其他元素的布局

方法：
	1.直接给父元素设置高度
		优点：简单粗暴
		缺点：有些布局中不能确定父元素的高度
	2.额外标签法，在父元素的最后一个浮动的子元素后面添加一个块元素，并设置其css样式为  clear:both,清除两边浮动
	缺点：在页面中添加了一个额外的标签，会让html中的页面结构变复杂
	3.单伪元素法：在父元素的最后的一个子元素后添加一个伪元素，设置清除浮动。
	优点，不占用html的结构
	缺点：每个要清除浮动的父元素都要设置一个伪元素
	解决办法,将清除浮动father类用一个习惯性的类替代
	4.双伪元素清除法
	 .clearfix::before,
     .clearfix::after{
      content: &#39;&#39;;
     display: table;/* 表格布局方式,类似block,习惯写法 */
      }
      .clearfix::after{
      		clear: both;/* 这个才是清除浮动的核心代码 */
      }
	清除浮动用的是后一个伪元素，给要清除浮动的父元素添加一个clearfix类
	双伪元素可以解决margin塌陷的问题
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="样式书写规范">样式书写规范</h3>
<pre tabindex="0"><code>1.布局  float，display等
2.宽高 width height
3.辅助背景等
4.盒子模型，内外边距
5.字体 文本等属性 等其他样式
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="定位">定位</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="简介">简介</h4>
<pre tabindex="0"><code>概念
	也是一种布局方式，可以让元素自由摆放在页面中的任意位置
应用场景
	可以解决盒子与盒子之间的层叠问题，因为定位元素的层级最高，可以叠在其他元素的上面，可以将盒子始终固定在页面的一个位置
使用
	1.设置定位的方式：position属性，共有三种模式
	2.设置偏移值：水平和垂直就近各取一个。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="相对定位">相对定位</h4>
<pre tabindex="0"><code>概念
	自恋型，相对于自己在标准流中的位置来进行定位
语法
	position:relative
特点
	1.在页面中占用空间的，没有脱标
	2.相对于自己原来在标准流中的位置移动的
	3.参照的坐标原点，以前在标准流的左上角为原点
应用场景
	1.子绝父相
	2.用于小范围的移动
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="绝对定位">绝对定位</h4>
<pre tabindex="0"><code>概念
	拼爹型定位，相对于最近的有定位的祖先元素进行移动的。
语法
	position: absolute;
特点
	1.不占用标准流中的位置，脱标了
	2.相对于最近的一个有定位的祖先元素移动
	3.参考的坐标原点，是最近的一个有定位的祖先元素的左上角，如果都没有，就参考body的左上角。
应用场景
	子绝父相（一种常用的布局技巧）
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="子绝父相">子绝父相</h4>
<pre tabindex="0"><code>含义
	一种常用的跟定位相关的布局技巧，子元素是绝对定位，父元素是相对定位。
作用
	可以让子元素相对于父元素进行自由移动
好处
	父元素是相对定位，不脱标，对网页的布局影响最小

应用场景
	1.实现元素水平居中，垂直居中
		top:50%;
		left:50%
		transform:translateX(-50%);
		transform:translateY(-50%);
		transform:translate(-50%,-50%);
		
		步骤：
			1.设置子绝父相
			2.先让子盒子向右移动父盒子的一半
			left:50%
			3.再让子盒子向左移动他自己的一半
				普通做法：margin-left:负的自身的一半
				缺点：要写死，不能灵活应用，如果子盒子宽度不固定，就无法实现。
				高级做法：transform:translateX(-50%) 实现水平居中。
				transform:translateY(-50%)实现垂直居中。
				同时实现水平居中和垂直居中，要注意覆盖问题，需要一次给transform属性设置XY偏移。transform:translate(-50%,-50%);
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="固定定位">固定定位</h4>
<pre tabindex="0"><code>概念
	死心眼定位，相对于浏览器进行定位
语法
	position:fixed;
特点
	1.在页面中不占位置，脱标的
	2.相对于浏览器进行定位移动
	3.参考原点为浏览器正文的左上角
场景
	让盒子固定在屏幕的某一位置
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="层级关系">层级关系</h4>
<pre tabindex="0"><code>不同布局之间的层级关系（优先级）
	标准流&lt;浮动&lt;定位
不同定位之间的层级关系
	相对，绝对定位之间的默认层级是相同的
	写在最下面的元素层级会更高，会覆盖上面的元素
	可以使用z-index属性更改元素的层级，z-index数字越大，层级越高，这样就不会更改html的结构
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="vertical-align">Vertical-align</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="概念-2">概念</h4>
<pre tabindex="0"><code>定义行内元素的基线相对于该元素所在行的基线的垂直对齐方式，默认是基线对齐
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="作用-1">作用</h4>
<pre tabindex="0"><code>用于解决行内元素和行内块元素的垂直对齐问题。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="取值">取值</h4>
<pre tabindex="0"><code>baseline 默认。元素放在父元素的基线上
top 把元素的顶端与行中最高元素的顶端对齐
middle 把此元素放置在父元素的中部
bottom  是元素及其后代元素的底部与整行的底部对齐。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="应用">应用</h4>
<pre tabindex="0"><code>1.解决img标签下面会存在额外间隙的问题
2.解决让img垂直居中的问题
3.解决img和文字对齐，需要设置文字行高line-height以及imgvertical-align为middle来设置图片与文字中部对齐。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="其他效果">其他效果</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="溢出效果">溢出效果</h4>
<pre tabindex="0"><code>属性
	overflow
作用
	控制内容部分的显示效果
取值
	visible 显示的，默认
	hidden 隐藏，超出边界会隐藏
	auto 自动显示，超出容器会以滚动显示
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="隐藏效果">隐藏效果</h4>
<pre tabindex="0"><code>visibility: hidden 隐藏元素本身，并且在网页中占据位置
display none 隐藏元素本身，并且在网页中不占位置,要显示的话，行级元素是inline，块级元素是block
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="字体图标">字体图标</h3>
<pre tabindex="0"><code>概念
	用来展示图标，本质是字体
网址
	https://www.iconfont.cn/
使用
  1.图标添加项目
  2.下载项目
	3.将字体包拖入项目中
	4.引入字体图标的样式
	5.调用图标对应的类名展示
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="css新特性">css新特性</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="1过渡">1.过渡</h4>
<pre tabindex="0"><code>transition: all(要过渡的属性) 过渡的时间;
作用
	让元素的样式慢慢变化
注意
	这属性需要给过渡的元素本身添加
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="2位移">2.位移</h4>
<pre tabindex="0"><code>transform:translate(X,Y);
括号里可以只写一个值，表示X轴,还有其他写法
transform:translateX();
transform:translateY();
transform:translatex() translateY();
XY为百分比的时候相当于相对自身的宽高的百分比进行位移
作用
	让元素沿着x轴或者y轴移动
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="3旋转">3.旋转</h4>
<pre tabindex="0"><code>目标
	使用rotate实现旋转的效果
语法
	transform:rotate(角度);
	注意，角度单位是deg
技巧:
	取正负均可，正顺时针旋转，负逆时针旋转
动画只有设置了过渡才动画效果。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="4渐变">4.渐变</h4>
<pre tabindex="0"><code>目标
	使用background-img:linear-gradient(颜色1，颜色2)实现渐变背景效果
特点
	渐变是多个颜色逐渐变化的视觉效果，一般用于设置盒子的背景

语法
	background-img:linear-gradient(
		颜色1，
		颜色2  ---这里不能有逗号，否则会报错
	)

应用设置背景图片带渐变色，使用渐变色image来盖住image标签
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="5动画">5.动画</h4>
<pre tabindex="0"><code>概念
	动画的本质是快速切换大量图片时在人脑中形成的具有连续性的画面，构成动画的最小单元，帧或动画帧。

利用过渡可以实现两个状态间的变化过程，那么
动画效果，就是实现多个状态间的变化过程，动画过程可控，能够重复播放，最终画面，是否暂停。

使用
	1.定义动画
	@keyframes 动画名称{
		from{}
		to{}
	}
	@keyframe 动画名称{
		0%{}
		10%{}
		15%{}
		100%{}
	}
	2.使用动画
	animation: 动画名称 动画花费时长;这两个值必须赋值
	使用animation 相关属性控制动画执行过程
	animation:动画名称 动画时长 速度曲线 延迟时间 重复次数 动画方向 执行完毕时状态;
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="flex布局">flex布局</h3>
<pre tabindex="0"><code>概念，flex布局，也叫弹性布局
	是一种浏览器提倡的布局模型
	布局网页更简单灵活
	避免浮动脱标的问题
作用
	基于flex精确灵活控制块级盒子的布局方式，避免浮动布局中脱离文档流现象发生。
	flex布局非常适合结构化布局

设置方式
	给父元素添加display:flex，子元素可以自动的挤压或拉伸
组成部分
	弹性容器
	弹性盒子
	主轴 默认水平方向为主轴，即元素默认是水平方向排布
	侧轴/交叉轴 垂直方向，如果主轴设置成了垂直方向，侧轴就是水平方向。

使用
	给父元素添加display:flex;
	根据需要添加相应轴的属性。
	主轴 
		justify-content:
			flex-start 默认，从左边开始
			flex-end 从右边开始
			center 水平居中
			space-between 两边没有间隙，中间间隙等分
			space-around 两边间隙是中间间隙的一半
			space-evenly 所有的间隙等分
		???justify-self 在flex布局中被忽略。
	侧轴对齐方式
		align-item
			flex-start 默认，从顶端
			flex-end 从底部
			center 垂直居中
			stretch 拉伸子元素，前提子元素没高度，设置高度就会从上开始flex-start
		align-self 单独修改某个子级的属性。
			值和align-item一样，但是设置在要设置的子元素上。align-item是设置在父元素上的。
		align-content设置行的对齐方式，其使用多与flex-wrap一起，其取值与justify-content一样，但没有space-evenly属性
		flex-wrap，弹性盒子能够换行，默认不能换行
			nowrap 无换行
			wrap 能够换行
			wrap-reverse 反向换行，即换行结果颠倒过来，在第一行的变到最后一行

弹性盒子伸缩比
	1.实现子元素宽度不一样
	flex:n; 取父元素剩余宽度的其中n份。

修改轴向：
	flex-direction:column
		此时主轴是垂直方向侧轴变为水平方向
		如果想实现水平居中，用align-items；
		如果实现垂直居中，用justify-content
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="flex布局的特点">flex布局的特点</h4>
<pre tabindex="0"><code>给了宽高，就按宽高走，不给，就按内容走，如果有拉伸，就跟父级元素一样大。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="浏览器调试技巧">浏览器调试技巧</h3>
<pre tabindex="0"><code>1.打开方式
	右键检查
2.选择元素
3.控制样式
	修改，添加，勾选
4.特殊情况
	出现删除线
	出现小三角
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="布局顺序">布局顺序</h3>
<pre tabindex="0"><code>大的方向上
	从上到下，从外到里，从左向右，先写通用，再写特殊
元素样式
	1.布局属性
		display，position float
	2.盒子模型+背景
		widht padding background
	3.文本内容属性
		font，color line-height
	4.点缀属性
		border-radius，阴影
	
推荐使用类+后代选择器，选择器的层级不超过三个。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="项目前置须知">项目前置须知</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="文件组成">文件组成</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="网页结构">网页结构</h4>
<pre tabindex="0"><code>设置网页语言
	&lt;html lang=&#34;zh-CN&#34;&gt;
SEO相关	
	title
	&lt;meta name=&#34;description&#34;...
	&lt;meta name=&#34;keywords&#34;
设置网页图标
	link rel=&#34;shortcut icon&#34;
引入样式
	base.css,一般是项目的基础样式，如清除默认样式等。
	link rel=&#34;stylesheet&#34; href=&#34;.css/base/base.css&#34;
	common.css，一般是一些公共样式，如头和尾等公共部分
	link rel=&#34;stylesheet&#34; href=&#34;.css/base/common.css&#34;
	index.css主页样式
	link rel=&#34;stylesheet&#34; href=&#34;.css/base/index.css&#34;
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="版心">版心</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="介绍">介绍</h5>
<pre tabindex="0"><code>把页面主体内容约束在网页中间
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="javascript">JavaScript</h2>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="概念及入门">概念及入门</h3>
<pre tabindex="0"><code>概念
	一种运行在客户端的脚本语言（script就是脚本语言）
用途
	表单动态的校验（密码强度）最初目的
	网页特效（轮播图）
	服务端开发 node.js
	桌面端开发
	控制硬件物联网
	游戏开发 cocos2d-js

组成
	ECMAScript 基础语法
	DOM 文档对象模型 访问文档的元素访问元素里的
	BOM 浏览器对象模型
引入方式
	1.内嵌式
		html中开一个script标签，将js代码中放进去
	2.外链式
		单独写一个js文件，将js代码写进去，在通过script src连接
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="变量">变量</h3>
<pre tabindex="0"><code>概念
	本质是内存上存储数据的一块空间
作用	
	存储变化的量
使用
	1.先声明，再赋值
	2.声明的同时再赋值
特点
	数据可以修改
命名规范
	变量的命名不能以数字开头，不能是关键字保留字，变量名要尽量见名知义
	变量命名可以是特殊符号，但尽量不用使用中文
	驼峰命名法 camel，多个单词组成的变量名，首单词首字母小写，其余单词首字母大写
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="数据类型">数据类型</h3>
<pre tabindex="0"><code>作用
	给数据进行分类，方便管理
分类
	基本数据类型
		number 数字型
			不是数字的字符串型转为NaN
			null转为0，undefined转为NaN
			flase为0 true为1
		string 字符型	&#39;&#39;或&#34;&#34;包起来的，通常单引号里不能有单引号，双引号里不能有双引号，除非用转义字符\&#34;  \&#39; ---和python很像
		boolean 布尔型（true false）
			为false的有0，null，undefined
		undefined 未定义（定义后没有赋值）
		null 空，对象
	引用数据类型
		类
		对象
		数组
		函数

数据类型的转换
强制转换
	Number() null--&gt;0,undefined--&gt;NaN,
	String()
	Boolean() &#39;&#39;,0,null,undefined--&gt;false
	parseInt()//会逐个解析，直到遇到非数字的内容，能够返回前面数字部分
	parseFloat()...

自动转换
	两边有一个是字符串，就会转成字符串，做字符串的加法连接
	没有字符串的话，会转成数字，不能转成数字的会转为NaN
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="运算符">运算符</h3>
<pre tabindex="0"><code>算术运算符
	+-*/
	注意点:
		1./就像是现实中的除法运算，不会因为整数除而保留整数。
		2.对于某些小数，结果可能不精准
		
自增自减
	++在前，变量先加一，再返回变量的值
	++在后，变量先返回它的值，再加1
	--规律一样
比较运算
	==,&gt;=,&lt;=,!=,===
	==值比较，只比较值，不比较类型，
		特殊情况，‘1’==true为true，有NaN参与的==都为false，!=都为true
		
	===全等于，还会比较类型
逻辑运算
	注意短路问题
复合赋值运算符
	+= -= *= /= %=
三元运算符
	表达式1?表达式2:表达式3
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="js中的输入输出">js中的输入输出</h3>
<pre tabindex="0"><code>输入 prompt
输出 alert，console.log
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="流程控制">流程控制</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="顺序结构">顺序结构</h4>
<pre tabindex="0"><code>一般代码都是顺序结构，执行顺序都是从上到下
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="选择结构">选择结构</h4>
<pre tabindex="0"><code>if else   switch case 
选择性的执行语句
if(bool表达式){
	执行的语句
}
else if(bool表达式){
	条件满足执行的语句
}
else{
	语句
}
if - else if执行特点，从上到下依次判断，如果满足则执行满足体，其余都不会执行。

switch case
	switch(表达式){
		case 值1:
			语句1
			break
		...
		default:
			语句
			break
	}
switch case里某一个break忘记写，执行完对应的case后还会往下继续执行。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="循环结构">循环结构</h4>
<pre tabindex="0"><code>for循环
	for(初始化语句;条件判断语句;循环增量语句){
		循环体语句
	}
	
双重循环
	外层循环执行一次,内层循环执行所有次
	外层循环控制行数,内层循环控制列数

while循环
	基本格式
		    while(条件){
                循环体语句
            }
	
	完整格式
		    初始化语句
            while(条件判断语句){
                循环体语句
                循环增量语句
            }
do-while循环
	基本格式
		do{
            循环体
        } 
	完整格式
		初始化语句
        do{
            循环体语句
            条件增量语句
        }while(条件判断语句)
区别
	while和for
		都是先判断条件,在执行循环体
	do-while
		不管条件是否成立,都会先执行一次循环体
		
应用场景
	循环次数确定,建议使用for循环,结构简单
	循环次数不确定,建议使用while循环
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="break-continue">break continue</h4>
<pre tabindex="0"><code>continue
	跳过本次循环,继续下一次循环
break
	终止当前循环
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="数组">数组</h3>
<pre tabindex="0"><code>概念
	javascript 中的数组在内存中并不是开辟了一个连续的空间。而是一种哈希映射型的链表。
作用 使用单独的变量名来存储一系列的值

声明
	1.常规方式
		var arr=new Array()
		arr[0]=...
	2.简洁方式
		var arr=new Array(1,2,3,&#39;3&#39;)
	3.字面方式
		var arr=[]
增加数组的元素
	var arr=[0,1,2]
	arr[4]=值
	此时跳过的索引3的位置为空，undefined
访问
	arr[0]
修改
	arr[1]=3
删除
	delete arr[3],并不会改变数组的长度，删掉的位置元素为undefined
	
二维数组
	即一维数组的每个元素是一个数组
	[[1,2,3],[1,2,3]]
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="函数">函数</h3>
<pre tabindex="0"><code>本质
	封装了一段特定功能的，可重用的代码

使用
	先定义再使用
语法
	function 函数名(){
		代码块
	}
形参，相当于一个媒介，调用者可以通过它将要操作的数据，传递到函数内部进行操作。

返回值 return
	就是方便函数将执行之后的结果返回给调用者。
如何获取函数传入的参数
	在函数内部有一个内置的变量arguments，是一个伪数组，利用它可以处理可变参数。

函数的分类
	普通函数（命名函数）
	匿名函数，通常用一个变量来接收
注意
	1.如果函数没有调用return，则函数没有返回值。
	2.函数名代表整个函数
	3.实参的个数少于形参，剩下的形参没有赋值，为undefined，多于形参，多出来的就相当于存在了arguments里，没用使用
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="面向过程">面向过程</h3>
<pre tabindex="0"><code>完成一件事，需要多少个步骤，关注重点是步骤
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="面向对象">面向对象</h3>
<pre tabindex="0"><code>概念
	完成一件事要多少个对象，关注重点是过程(重点在于找对象，调用方法)
类
	类是对现实生活中具有相同属性和行为的事物的一个统称(抽象的)
对象
	现实生活中一个具体的存在。通过类模板创建出来的。
类和对象的关系
	类是模板，对象是通过这个模板创建出来的一个个真实存在的个体
	
类的三要素
	类名
	属性:这类事物所具有的特征
	行为:这类事物所具有的功能

为啥要学习类和对象
	用代码描述现实生活中的事物，再进行编程。
	
类的定义
	1.用构造函数来定义，构造函数函数名大写。
		function Person(参数1，参数2){
			this.属性名1=参数1
			this.属性名2=参数2
			this.方法名=function(){}
			
		}
	2.字面量创建对象
		var zhangsan={
			name:&#39;&#39;,
			age:值,
			...
			方法:function(){
				
			},
		}
	3.new Object()创建
对象的定义
	var 对象名=new 类名(参数)

对象的属性，方法的调用
	对象名.属性名
	对象名.方法名

内存中的使用
	1.栈区，一般存放局部变量
	2.堆区，存放引用类型，
var p=new Person()这一过程在内存中的情况
	1.在栈区中声明了一个变量。
	2.在堆区中开辟了一块空间，存放对象的属性，方法
	3.this 指向了这块空间
	4.执行函数体(就是给属性和方法赋值)
	5.返回空间中的首地址给p，p存放的是对象的首地址。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="math对象">Math对象</h3>
<pre tabindex="0"><code>算数相关的内置的对象
属性
	PI 圆周率

方法
	max,min 最大最小
	abs 绝对值
	round 四舍五入
	floor 向下取整
	ceil 向上取整
	trunc 保留整数部分，去掉小数部分
	
	random 0-1伪随机数，是左开右闭区间，想要特定范围的数可以通过Math.random()*(max-min)+min，想要整数可以通过floor(Math.random()*(max-min)+min)
	想要闭区间，可以Math.floor(Math.random()*(max-min+1)+min)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="date对象">Date对象</h3>
<pre tabindex="0"><code>概念
	用于处理日期和时间的类
创建
	new Date()
	new Date(2020,4,7)
	new Date(&#39;2020-5-7&#39;)
	
获取年月日
	getFullYear()
	getMonth()
	getDate()
	getDay()

获取时分秒
	getHours()
	getMinutes()
	getSeconds()

获取1970年至某一时刻的毫秒值
	getTime()
	ValueOf()
	Date.now()
	+new Date()
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="array对象">Array对象</h3>
<pre tabindex="0"><code>数组对象的创建
	new Array(2)----2指的是数组的长度
	new Array(&#39;2&#39;)----数组的元素
	非数字型参数，或者多个参数会是数组的元素，单个数字型参数会是数组的长度，如果是小数负数就会报错。
	
方法
	push(参数1[,参数2...])数组尾部依次添加多个元素
	pop() 删除尾部元素
	splice(index,howmany,item1,...), 在索引位置的前面添加一个元素，或者删除当前索引的元素，howmany是删除的个数，如果为0，表示添加，返回删掉的元素的数组，会修改原数组
	//注意，在进行操作过程中浏览器调试模块会根据内存实际情况而显示结果，比如前面打印了添加元素的数组，后面有给数组元素删除了一些，那么调试结果中会显示实际的删了元素之后的数组，打印的结果不会变，点开来显示的内容会显示最后的结果
	reverse()反转
	sort()排序，默认升序，字母形式排序，如果想要数字型排序，就要指定一个函数例如
		sort(function(a,b){
      //a 是后一个元素，b是前一个元素，a-b&gt;0说明是后一个大于前一个，要升序排列
			return a-b---升序
			return b-a---降序
			//会根据函数返回值的正负进行排序，a，b相当与排序过程中传入的两个要比较的数组的元素
		})
	indexOf() 返回元素第一个出现的索引
	lastIndexOf() 返回元素最后一个出现的索引
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="string对象">String对象</h3>
<pre tabindex="0"><code>相当于一个可读的字符型数组
方法	
	indexOf()
	lastIndexOf()
	charAt()
	substr()
	substring() 子串
	replace() 替换
	split([&#39;指定分隔符&#39;][,limit 字符串数组的长度]) 分隔子串
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="json对象">Json对象</h3>
<pre tabindex="0"><code>json 
	本质是一个字符串，是一种简单轻量级的数据传输格式。是格式化的字符串。
json对象
	是一个类的实例，是对象
传输
	json字符串可以跨平台传输速度快
	js对象，不能传输
表现
	json字符串
		键值对形式，属性必须要加引号
		值不可以是方法，函数，undefined，NaN
	js对象
		键值对方式，属性可以不加引号
		值可以是函数，对象，字符串，数值，boolean等。

json-&gt;js对象
	Json.parse()
js对象-&gt;json字符串
	Json.stringify()
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="dom概念">DOM概念</h3>
<pre tabindex="0"><code>文档对象模型(Document Object Model)
DON将HTML 文档表达为树结构。
DOM定义了一个访问和操作html文档的方法。
HTML DOM 定义了HTML元素的对象和属性，以及访问它们的方法。
HTML DOM 是关于如何获取修改添加删除HTML元素的标准。

Document 对象 内置对象
	当浏览器载入HTML文档，它就会成为Document对象
	Document是对象html文档的根节点
	Document对象使我们可以从脚本中对HTML页面中的所有元素进行访问
	
HTML DOM 节点
	在HTML DOM中，每个元素都是一个节点
	文档是一个文档节点
	元素是节点
	属性是节点
	文本也是文本节点
	注释是注释节点
	
DOM操作思想
	将html页面中的所有组成部分(标签，属性，标签体，注释)抽象成对象，用面向对象的方式来操作这些东西(对象中有属性和方法，比单纯操作字符串方便很多)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="dom">DOM</h3>
<pre tabindex="0"><code>属性
文档元素
	innerHtml 获取标签内容包括标签里的标签，
	innerText 获取标签内文本
	
	style.属性名 属性名有-的都用驼峰命名法，去掉-。 获取设置元素样式
	className 设置css样式，在css中写一个样式，可以通过这个属性来修改或添加样式，多类名选择器可以保留原来的样式，前提是没有样式覆盖的情况。
	
	
方法
document
	getElementById() 获取指定id的元素
	getElementsByClassName()，获取多个同类的元素
	getElementsByTagName() 获取同类标签
	
	h5新增 推荐
	querySelector(选择器) 获取选择器所指定的第一个元素
	querySelectorAll(选择器) 获取选择器选中的所有元素
	上面这些获取元素的方法括号内要加引号。
</code></pre><p>
  <p><img src="images/image-20220509103917914.png#id=WViF8&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy" /></p>
</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="事件">事件</h4>
<pre tabindex="0"><code>事件通常要和js代码一起使用，来完成一些动态效果。
三个要素
	1.事件源，触发事件的对象
	2.事件，触发的具体事情
	3.事件处理程序，事件发生后需要做的事情
	
	通过按钮来演示
		1.事件源 按钮
		2.事件 点击动作
		3.事件处理程序 点击之后弹出的消息
步骤
	1.写一个事件源 
	2.写一个监听器
	3.绑定监听器和事件源 通过一个属性将二者绑定在一块
	

常用事件属性
	onclick 点击
	onfocus 获得焦点
	onblur 失去焦点
	
	onmouseover，鼠标进入元素范围触发事件，当进入元素子元素时，也会触发，这一点不同于下面的onmouseenter，只会触发一次，除非���次进入元素或子元素。
	onmouseenter，进入元素才会触发事件，进入后在元素上移动就不会出发事件，除非移除后再次进入。
	onmousemove,鼠标移动到元素上触发，并且只要在元素上移动就会发生事件
	onmouseleave 鼠标移出某元素时触发，通常与onmouseenter一起使用，离开子元素不会触发，不支持冒泡。
	onmouseout，离开元素，离开元素进入子元素，离开子元素进入父元素或者离开子元素进入另一子元素。
	
	 onkeypress 事件只能监听字母和数字，不能监听一些特殊按键（ALT、CTRL、SHIFT、ESC、箭头等）。监听一个用户是否按下按键请使用 onkeydown 事件,所有浏览器都支持 onkeydown 事件。
	 onkeydown	按下时触发
	 onkeyup 按键抬起时触发，输入框相关的推荐使用keyup，因为keydown会把按键内容输进去，如果时聚焦相关的操作。
	 
h5新增添加事件监听，本质是给元素添加方法，可以多次添加，而不像事件属性那样会被覆盖。
addEventListener(&#39;事件&#39;,function(e){})
	常见事件
		click  
			关于设置按钮无法触发，防止事件多次触发，btn.disabled=true 无法再被点击，注意要修改回false
		focus blur
		mouseover mouseout
		keydown keyup keypress
		页面加载 load
		内容改变 change
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="事件对象">事件对象</h4>
<pre tabindex="0"><code>概念
	事件发生时，跟事件相关的一系列信息数据的集合都会放到这个对象中，这对象就是事件对象。
	比如
		1.谁绑定了这个事件
		2.鼠标触发了事件，可以得到鼠标的相关信息，鼠标的位置
		3.键盘出发了事件，可以得到键盘的相关信息，比如按了哪个键

获取
	事件触发的时候会产生事件对象，并且系统会以实参的形式传给事件处理函数。
	我们可以在事件处理函数声明一个形参来接收事件对象

作用
	1.获取事件的类型 e.type
	2.可以在键盘事件获取按了哪个键 e.keyCode
	3.可以阻止有些标签的默认行为(a标签的默认跳转) e.preventDefault()
	4.可以获取具体点击了哪一个 e.target
	5.可以阻止事件冒泡
事件冒泡
	事件具有传递性，一开始由具体元素接收，然后逐级向上传播到DOM最顶级的节点
	有些情况下，我们只想让最具体的元素接收，而不想让事件向上传递，就可以使用事件对象来阻止冒泡。e.stopPropagation()
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="dom节点操作">DOM节点操作</h4>
<pre tabindex="0"><code>属性
	children 获取父元素下的所有子元素注意是子元素，非后代元素，？？？是一个数组
	parentNode 获取父节点
	

创建元素
	document.createElement(&#39;元素标签名&#39;)
	
插入元素
	父元素.append(元素对象1，元素对象2...)
	父元素.appendChild(元素对象) 添加到父元素的子元素的最后面
	父元素.insertBefore(插入的元素,某个子元素),插入到父元素的某个子元素的前面,insertBefore(元素,父元素.children[0])，插入到最前面

移除元素
	父元素.removeChild(元素对象（包括已存在的或者是通过代码创建的）)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="bom">BOM</h3>
<pre tabindex="0"><code>概念
	浏览器对象模型
作用
	使javascript可以操作浏览器，有能力与浏览器&#34;对话&#34;。
	比如：
		弹框
		跳转窗口
		新建窗口
组成
	window 对象
		表示浏览器窗口
		所有js的全局对象，函数变量均自动成为window对象的成员。
	Navigator 包含有关访问者浏览器的信息
	Screen 屏幕对象，包含有关屏幕信息
	History
		历史记录对象，包含浏览器历史
		history.back() 回到上一页
		history.forward() 回到下一页
		history.go(-1) 上一页
		history.go(1) 下一页
		history.go(0) 刷新页面
	Location
		地址栏，用于获取当前页面的地址 url，并把浏览器重新定向到新的页面。

操作思想
	将浏览器各个组成部分抽象成对象，以面向对象的方式来操作(对象有属性和方法),提高开发效率
	
计时器
	setTimeout(要调用的函数,等待的时间)
	setInterval(回调函数,间隔时间) 会按指定时间间隔，来执行回调函数(不会立即执行，根据指定时间来执行)
关闭定时
	可以用变量存储定时器
关闭定时器
	clearTimerout(定时器变量)
	clearInterval(定时器变量)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="jquery">JQuery</h3>
<pre tabindex="0"><code>概念
	1个js的函数库，对原生的js进行了封装，可以处理兼容性问题，方便对dom的操作

作用
	-HTML 元素获取
	-HTML 元素操作
	-CSS 操作
	-HTML 事件函数
	-javascript 动画特效
	-HTML DOM 遍历和修改
	-AJAX
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="入门案例">入门案例</h4>
<pre tabindex="0"><code>1.引入
	1.本地引入
	2.网络引入

2.编写代码
	$(&#39;选择器&#39;).方法
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="基础语法">基础语法</h4>
<pre tabindex="0"><code>1.$
	是jQuery的别名，是jquery的顶级对象，大部分方法都是通过$来调用

2.dom对象(是原生js的对象)，与jquery的区别
	来源不同
		dom通过documnet来获取的
		jquery对象主要是通过$来获取的
	调用机制
		dom对象本质是操作元素的属性
		jquery本质是调用方法来操作
	两者不能混用
3.dom对象和jquery对象的互转
	dom-&gt;jquery $(dom对象)  相当于把dom对象存到了伪数组里
	jquery-&gt;dom jquery对象[index]，取出伪数组里的dom对象或者 jquery对象.get(index)
	dom-&gt;jquery对象用的多，为了用jquery的方法

4.jquery事件入门
	$(&#39;选择器&#39;).事件(function(e){})
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="jquery选择器">jquery选择器</h4>
<pre tabindex="0"><code>1.基本选择器，包括元素 类 id选择器
2.css中的选择器在jquery中都能用
	并集选择器
	交集选择器
	后代选择器
	子选择器
	伪类选择器
	属性选择器
	相邻兄弟选择器
3.jquery筛选器
	:first 选择同类父元素的子元素中的第一个元素
	:last 最后一个
	:eq(index) 同类第index个 从0开始
	:not(selector) 选中的元素中非selector选中的元素
	:even 奇数
	:odd 偶索引
	:gt(index) 大于某个索引的不包括
	:lt(index) 小于某个索引的不包括
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="jquery筛选方法">jquery筛选方法</h4>
<pre tabindex="0"><code>expr表示一个选择器字符串
ele dom元素
fn 函数 用于检查集合中的每个元素
obj 现有jquery对象
index 整数，负的表示从尾部开始索引

都是对当前元素集合的操作，隐式迭代了对每个元素进行调用了方法。
子元素
	first()
	last()
	eq(+-index)
	children(expr) 所有子元素，不包括后代元素
父元素
	parent(expr) 

祖先元素
	parents(expr)
后代元素
	find(expr)

兄弟元素
	next(expr) 紧邻的后面兄弟元素
	nextAll(expr) 后面的同辈元素
	siblings(expr) 同辈元素集合,不包括this自己

特殊
	not(expr|ele|fn) 选择非某条件元素
	hasClass(expr) 检查当前元素集合中是否有某个元素含有某类，有返回true没有false，多用于单个元素检查，多个不会报错。 相当于is(&#39;.&#39;+class)
	is(expr|ele|fn|obj) 检查当前元素集合是否有元素满足条件，有返回true，否则返回false,可以通过选择器相结合来判断元素是否是处于某一状态。如is(&#39;:focus&#39;)判断是否聚焦
	
有筛选方法，优先使用筛选方法
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="jquery核心函数">jquery核心函数</h4>
<pre tabindex="0"><code>index([selector|element]) 获取索引,不写就是返回当前对象在同辈中的索引，传递参数可以是dom对象或jquery选择器，返回这个对象在调用函数的元素集合中的索引位置，传入一组则返回的是第一个的索引。

链式编程法，如果一个函数返回的是对象，则可以继续调用该对象的函数，如$().show().siblings().hide()
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="jquerydom操作">jqueryDOM操作</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="jquery-css操作">jquery css操作</h5>
<pre tabindex="0"><code>1.css(属性名，[属性值]) 
	一个参数是获取属性，两个参数是设置属性。也可以通过下面的方法批量设置属性(不推荐)
	css({
		width:100,
		backgroundColor:&#39;blue&#39;
	})


2.addClass(类名)
	添加css类

3.removeClass(类名)
	移除css类

4.toggleClass(类名)
	有删除类，没有添加类
类名非选择器，不用加点
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="jquery-操作属性">jquery 操作属性</h5>
<pre tabindex="0"><code>
prop(name|key,value|key,function(index,attr)) 
	操作元素固有的属性

attr(name|key,value|key,function(index,attr)) 
	还可以操作元素自定义的属性
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="操作文本">操作文本</h5>
<pre tabindex="0"><code>html()
	有参数是设置，无参数是获取，可以设置标签
text()
	同上，只设置文本，会把内部标签也设置掉，变为文本
val()
	处理表单相关的值value，有参数是设置，无是获取
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="操作节点">操作节点</h5>
<pre tabindex="0"><code>创建节点
	$(&#39;标签字符串如&lt;p&gt;文本&lt;/p&gt;&#39;)
添加节点
	append(content)内部追加内容
	appendTo(content)将匹配的元素追加到另一元素集合
	prepend(content)内部前置内容
	content可以是节点，文本等
删除元素
	remove([expr])移除当前元素集合内符合条件的元素,如果没有参数则移除自身，除了保留了该移除的jquery对象，相绑定的事件数据都会移除
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="jquery-动画">jquery 动画</h4>
<pre tabindex="0"><code>基本效果
	show()
	hide()
	toggle() 如果显示就隐藏,隐藏就显示
可以有两个参数,第一个是动画时间,第二个是动画结束后执行的函数,不写参数没有动画效果

上滑下滑 具体参数三个,可以查看文档
	slideDown()
	slideUp()
	slideToggle() 上滑下滑切换

停止动画的排队
	stop()

淡入淡出
	fadeIn()
	fadeOut()
	fadeToggle()
	fadeTo([speed],opacity,[easing],[fn])

可以有两个参数,第一个是动画时间,第二个是动画结束后执行的函数
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="jquery-遍历">jquery 遍历</h4>
<pre tabindex="0"><code>最简单的遍历方法 
jquery对象.each(function(index,ele){}) 
	index表示当前遍历到的元素的索引
	ele表示遍历到的元素dom 对象

$.each(遍历的对象,fn(i,e)),可以遍历字面量对象，如{name: ,age: 12},此时i表示key，e表示value
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="jquery事件">jquery事件</h4>
<pre tabindex="0"><code>事件绑定
	on(events,[selector],[data],fn)
	events 一个或多个用空格分隔的事件类型和可选的命名空间
	selector 选择器字符串，用于过滤器的触发事件的选择元素的后代。多用于子元素事件绑定父元素
	data 事件触发时要传递event.data给事件处理函数
	fn 事件触发执行的函数
		1.可以绑定多个不同类型的事件
		2.可以实现事件委托(可以把子元素事件绑定到父元素上)
		3.可以实现动态绑定 父元素.on(事件名称,子元素选择器,匿名函数)
事件解绑
	off(event,selector,fn)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="js高级语法">js高级语法</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="作用域">作用域</h4>
<pre tabindex="0"><code>概念
	变量起作用的范围可以提高程序的可靠性，减少命名冲突
	分为全局作用域与局部作用域与块级作用域

局部作用域
	是☞函数内部定义的变量，其变量值仅在函数内生效。
	局部变量是局部作用域下的变量，范围是函数内部

全局
	是在整个页面都生效，当然是要在变量定义后的部分有值，前面的话是undefined。
	全局作用域下的变量，范围是整个script标签。
	全局变量在浏览器关闭的时候销毁，局部变量在函数运行结束后销毁。

块级作用域
	是指在{}内的不包括函数的括号，像是选择结构，循环结构的{}，是ES6新增的概念，一般需要let关键字定义

作用域链
	在同一个作用域下写一个函数，在这个函数中右写了一个函数，则形成了一个作用域链，内部函数使用外部变量时，会逐层向上查找同名变量，找到就停止，都找不到就报错。就近原则
	在连续的作用域下声明相同名称的变量，则对函数取值时，按就近原则，只找最近的定义的变量的值
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="全局变量的定义">全局变量的定义</h4>
<pre tabindex="0"><code>1. 变量名=值 不加var的都是全局变量，但不推荐

2.window.变量名=值

3.在非函数内部的script标签里定义的变量 var 变量
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="预解析">预解析</h4>
<pre tabindex="0"><code>js引擎的执行顺序
	1.先预解析
	2.执行代码
预解析
	变量的预解析
		变量的声明，会放到当前作用域的最前面，不会提升赋值操作
	函数的预解析
		函数的声明会被提升到当前作用域的最前面，不会提升调用操作
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="原型和this指向">原型和this指向</h4>
<pre tabindex="0"><code>对象的三种创建方法
	1.构造函数
	2.字面量
	3.new object
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="静态成员和实例成员">静态成员和实例成员</h4>
<pre tabindex="0"><code>实例成员
	是通过对象.成员名来进行调用或创建的

静态成员
	是通过类.成员名来进行调用和创建的，通常存放一类对象的通用的属性或方法
	
new 关键字在内存中的操作原理
	1.在堆区开辟空间用于存放对象
	2.让this指向这个空间
	3.执行构造函数中的代码
	4.返回空间的地址
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="构造函数的问题">构造函数的问题</h4>
<pre tabindex="0"><code>构造函数内部定义的方法，每创建一个对象，对象的方法都会分配空间，会极大浪费内存空间。(本来只需要一个方法内存空间就能解决的问题，有几个对象就有几个方法的内存空间)

解决方案
	通过原型对象来解决内存占用的问题，将对象共有的方法定义在原型对象prototype下，构造函数里只需要写共有的属性即可。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="原型对象-prototype">原型对象 prototype</h4>
<pre tabindex="0"><code>概念
	js规定，每个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype本质上就是一个对象，其具有的成员(属性，方法)会被构造函数所拥有。
	是一个对象，每个构造函数都有这样一个对象。
作用
	把不变的方法，直接定义到prototype对象中，所有对象实例都可以共享这些方法，解决了构造函数创建方法的内存浪费问题。

总结
	一般情况下，把属性定义到构造函数中，共用的方法定义到原型对象prototype中，可以节省内存。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="对象原型-proto">对象原型 <strong>proto</strong></h4>
<pre tabindex="0"><code>概念
	每一个对象都有一个属性__proto__指向构造函数的prototype属性，也就是__proto__指向构造函数的原型对象。
	__proto__习惯称之为对象的原型
作用
	为对象查找方法提供了一个方向，对象在调用方法的时候，先去构造函数中找，没有就通过对象的原型 到 原型对象中去找，没有就报错。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="constructor-构造器构造函数">constructor 构造器(构造函数)</h4>
<pre tabindex="0"><code>概念
	原型对象，和对象的原型，里面都有一个constructor，又成为构造函数，指向构造函数本身。
	
作用
	记录该对象引用于哪个构造函数，可以让原型对象重新指向原来的构造函数
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="原型链">原型链</h4>
<pre tabindex="0"><code>一个对象的原型，指向的是构造函数的原型对象
一个对象的原型的原型，指向的是object类的原型对象(如果没有其他继承的话)
一个对象的原型的原型原型(object 的原型对象的原型)是null

概念
	每一个对象都有一个__proto__属性，是该对象的原型，指向构造函数的原型对象，构造函数的原型对象，也有原型，这样一层层向上找，就形成了原型链。

作用
	对象调用方法的时候，先在构造函数里找，没有就在原型(构造函数的原型对象)里找，还没有，就往原型的原型里找，一层层向上，直到找到Object类，才停止。

JavaScript 成员查找机制
	1.当访问对象的成员的时候，首先查找对象自身(构造函数或者自己额外定义的)有没有
	2.如果没有，就到原型中去查找，也就是__proto__指向的原型对象(构造函数的prototype)
	3.如果没有，就查找原型对象的原型，即上一层(如果没有继承的话，就是Object)的原型对象
	4.依次类推，找到Object的原型
从上面可以看出，继承关系不应级数过多
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="原型对象中的this指向">原型对象中的this指向</h4>
<pre tabindex="0"><code>指向的是当前调用方法的对象，如果没有调用，就是undefined。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="函数进阶">函数进阶</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="函数定义总结">函数定义总结</h5>
<pre tabindex="0"><code>1.命名函数 function fn(){}
2.匿名函数总结 var f=function(){}
3.new Function(&#39;参数1&#39;,&#39;参数2&#39;,...,&#39;函数体&#39;)，这种方法使用起来很不方便，不推荐
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="函数调用总结">函数调用总结</h5>
<pre tabindex="0"><code>1.命名函数 fn()
2.匿名函数 f()
3.对象中的方法 对象名.方法
4.立即执行函数 (匿名函数)(参数有就写，没有就空着) 前后记得加分号，不然可能会报错
5.构造函数的调用 new 构造函数
6.事件中的函数 事件触发调用
7.定时器 根据时间自动调用
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="函数this指向总结">函数this指向总结</h5>
<pre tabindex="0"><code>1.命名函数  window
2.匿名函数 window
3.new Function() window
4.字面量对象的方法 当前对象
5.事件  触发事件的元素
6.立即执行函数 window
7.构造函数 指向对象
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="改变函数this的指向">改变函数this的指向</h5>
<pre tabindex="0"><code>函数名.call(this指向的对象,函数的参数)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="高阶函数">高阶函数</h5>
<pre tabindex="0"><code>函数也是一种数据类型，可以作为参数和返回值
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="函数闭包">函数闭包</h5>
<pre tabindex="0"><code>有权访问另一函数作用域内的变量，例如内部函数访问了外部函数的变量，这个变量所在的函数就叫作闭包
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="let声明变量">let声明变量</h4>
<pre tabindex="0"><code>1.作用域是块级
2.无法重复声明
3.没有变量提升
4.防止循环变量成为全局变量

暂时性死区
	块级作用域外var 定义了一个变量，在内部试图使用这个变量，然后后面又用let定义了一个同名变量，就会导致报错，因为该变量在块级作用域中受到了let的影响，不写let不会报错
	var num=10
	if(true){
		console.log(num)//报错
		let num=20
	}
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="const">const</h4>
<pre tabindex="0"><code>定义的一般为常量，不会变化的量，不能被修改，防止出现无意间修改导致的麻烦。


			var  	let  	const
作用域	  	  函数级 	块级	   块级
变量提升  	  会		 不会		不会
能否被修改	 可以	    可以	  不可以
能否重复声明  可以 	   不可以   不可以
暂时性死区	 无		 有		有
先声明后初始化 可以	   可以	  不能，必须声明的同时初始化
适用场景
let一般用于定义基本数据类型的变量
const 一般用于定义引用类型的变量，因为存放的是地址，地址指向的内容改变并不影响定义的变量的内容
优先选用const ，如果定义的变量要修改，用let
使用顺序 const &gt; let &gt; var
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="类和继承">类和继承</h4>
<pre tabindex="0"><code>概念
	ES6中 class(类)作为对象的模板被引入，可以通过class 关键字定义类，class本质是一个function,可以看成是一个语法糖，使用起来很方便
	
格式
	定义类
		class 类名{
			constructor(参数列表){
				this.属性名=变量名
			}
			方法名(){
				
			}
		}

继承
	class Son extends Father{
		constructor(参数1，参数2...){
			super(参数1)//调用父类的构造方法的内容省写了代码
			this.属性=参数2
			...
		}
	}
	特点
super的作用 
	相当于父类的别名 ，直接super()表示构造方法，super.成员可以调用父类的成员，包括函数属性
		子类会继承父类的属性和方法,包括构造函数的形式也会继承
注意点
	1.类名单词首字母大写，
	2.类中的语句用分号隔开，换行，分号可省略。
	3.类中有一个constructor构造函数，可以通过它来对对象初始化，不写这个函数，会自动生成一个无参，无函数体的构造函数。
	4.类中的方法定义在prototype里的
	5.new的时候，调用的是constructor
	6.方法不用写function
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="解构赋值">解构赋值</h4>
<pre tabindex="0"><code>概念
	是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值

分类	
	数组解构
		格式 const[变量列表]=数组
	对象解构
		const{变量列表}=对象 要考虑变量列表与成员名相对应。
		或者 const {key:value,...}=对象，这里的key必须是对象中定义好的成员名，如果不是就会报错，可以不考虑顺序就相当于通过键值对形式获取值。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="箭头函数lambda-表达式">箭头函数(Lambda 表达式)</h4>
<pre tabindex="0"><code>作用
	提供了一种更简洁的函数书写方式
语法
	(参数)=&gt;{函数体} 相当于匿名函数省略了function，比起匿名函数可以直接写，但是这样直接写并没有用，通过变量来接收。如果函数体里只有一个语句，大括号可以省略，单有return的话还要写大括号或者把return省略，参数只有一个，()可以省略。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="promise">promise</h4>
<pre tabindex="0"><code>promise 是一个对象
promise 必然处于三个状态中的一个 pending，fulfilled，rejected
语法 new Promise(executor) 
	executor 是一个函数参数，该函数的签名也就是参数
  必须是(resolutionFunc,rejectionFunc)，这两个参数也是函数，
  可以为任何名字，通常为 resolutionFunc(value) rejectionFunc(reason)

属性
	状态属性 PromiseState 通过resolve,reject 来改变为fulfilled和
  rejected 默认是pending状态
	结果属性 PromiseResult ，通过resolve(value)或者
  reject(reason)来传递，其中的参数会传给结果属性，
  value保存的是成功的信息，reason保存的是失败的信息
	
方法
	then(promise对象状态为fulfilled执行的函数[，promise对象状态为rejected执行的函数])
	then 返回的是一个promise对象，如果then方法执行成功(表示执行两个里面的任意一个函数并且成功，与调用then的promise对象的状态无关)，返回的promise对象的状态就是fulfilled，否则执行过程出现异常，或错误，程序没执行完，返回对象的状态为rejected
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="mysql">MySQL</h2>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="数据库概念">数据库概念</h3>
<pre tabindex="0"><code>数据库是存储数据的文件系统，通过标准的sql访问，方便我们对数据的管理。
是由一张张表组成的，每张表由一行行数据构成，每行数据由字段值构成。
一般一个项目会创建一个数据库，一般一个实体会创建一张表，一个对象的实例就是在表中添加一条记录。

sql 结构化查询语句，数据定义语言DDL，数据操纵语言DML 数据查询语言DQL 数据控制语言DCL。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="数据类型-1">数据类型</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="整形">整形</h4>
<pre tabindex="0"><code>tinyint 8位二进制 1个字节 2^8
smallint 2个 2^16
int/integer 4个
bigint 8个
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="浮点型">浮点型</h4>
<pre tabindex="0"><code>float(m,d) m精度，表示总位数，d标度，表示小数点后的位数 4个字节
double(m,d)  8个字节
decimal(m,d) --钱常用类型
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="字符型">字符型</h4>
<pre tabindex="0"><code>char(M) 定长
varchar(M) 变长，理论范围0-65535字符
text 允许长度 0-65535字节
enum(值1,值2...) 枚举
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="日期和时间类型">日期和时间类型</h4>
<pre tabindex="0"><code>date 3个字节 2000-10-07 1000-01-01~99999-12-31
time 3个字节 
year 1个字节 1901~2155
datetime 8个字节 1000-01-01 00:00:00~99999-12-31 23:59:59
timestamp 4个字节 1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="字段属性">字段属性</h3>
<pre tabindex="0"><code>1.能否为空
	不设置就可以为null
	设置为not null
2.默认值
	使用default来设置
3.主键
	主键唯一，不为空，可以有多个
	作用 用来标识唯一的一行
	看需要可以设置自动递增
	使用 primary key 来标识
4.自增
	一般会和主键一起使用，可以让id序号自动增长，这个主键id序号不能重复使用，比如删除掉id为5的再添加一条记录，id为6
	使用 auto_increment 设置

5.注释 
	作用：解释说明当前字段，给程序员看的
	使用comment 设置
6.唯一
	作用：让列表中的数据保持唯一
	使用UNIQUE KEY

创建一个博客blog 表
	字段			字段类型	字段属性
	id	  			int		主键 自动增长	
	title	 	varchar(255)	非空
	publish_time 	date	 非空
	view		    int		 非空 default 0
	comments 		int		 非空 default 0
	content			text	 非空
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="建库操作">建库操作</h3>
<pre tabindex="0"><code>Create database db01;
use db01;
create table tb01(
	id int primary key auto_increment,
	字段 数据类型 字段属性
	username varchar(20) not null unqiue,
	password varchar(20) not null
)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="数据写操作">数据写操作</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="增加-insert">增加 insert</h4>
<pre tabindex="0"><code>insert into 表名(字段1，字段2，字段3 可以省略，省略表示插入所有字段) values(值1，值2，值3)，(值1，值2，值3)

注意
	可以插入部分字段，前面要写好部分字段的名称并且省略的字段没有非空约束，相当于其他字段为null，除了设置了自动增加的主键。
	可以插入多条记录，在values的后面有几个括号，就有几条记录，记录间用逗号隔开
	新建查询要切换到对应的数据库,才能找到对应的表
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="修改-update">修改 update</h4>
<pre tabindex="0"><code>update 表名 set 字段 = 值 where 字段 = 值
注意 不写where 会修改所有记录该字段的值
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="删除记录-delete">删除记录 delete</h4>
<pre tabindex="0"><code>delete from 表名 where id=0
注意 一半都是通过id来删除记录
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="注意">注意</h4>
<pre tabindex="0"><code>1.增删改的数据，会进行一个类型转换,能转换的数据会进行操作不能转换的数据会报错
2. 修改和删除一定要加条件，否则会影响到所有数据
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="数据查询">数据查询</h3>
<pre tabindex="0"><code>查询所有
	select * from 表名 --一般和分页查询结合使用
条件查询
	select 字段1，字段2，字段3 as 别名3 from 表明 where 条件
	
模糊查询
	%代表0，1，或多个字符
	_ 匹配一个字符，注意mysql里汉字占1个字符
	%x%
	_x_
	...
聚合函数查询 ---查询结果是单值
	max(字段)
	min(字段)
	sum(字段)
	avg(字段)
	count(*)

where + group by 
	先where再分组
group by +having 
	先group by 再having
	
	注意，分组之后的查询字段，一般为聚合函数或者是分组字段，查询语句是对分组后的每一组进行查询，如果查询的不是分组字段，只会显示那一组的第一个记录对应的字段值。
	
select 字段或字段表达式 from 表 [where 分组前条件过滤] group by 字段 [having 分组后条件过滤] [order by 字段 [desc/asc]]


分页查询
	limit 当前页的第一个记录在表中的索引(从0开始),页面显示条数
	
总结 select * from 表 [where 查询前过滤] group by 字段  [having 查询后过滤] [order by 字段 asc/desc] limit 首索引，页面条数
select--from--where---group by-- having--order by--limit
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="单表约束">单表约束</h3>
<pre tabindex="0"><code>主键约束
	primary key
非空约束
	not null
唯一约束
	unique
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="多表约束">多表约束</h3>
<pre tabindex="0"><code>外键约束
	foreign key(当前表的某一个要约束为外键的字段) reference(另一张表中的主键)
	作用 保证数据的完整性和有效性，有了外键约束，就不能随便删除表中的记录。

代码实现外键约束
	alert table 表名 add constraint foreign key(外键字段) references 另一张表(主键字段)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="多表关系">多表关系</h3>
<pre tabindex="0"><code>一对一
	建表原则
		在任意一方，添加外键指向另一表的主键，并且外键唯一 -----说明，外键可以是主键
	应用
		数据库优化(后台) 分表(把一张表分成2张表)
一对多
	建表原则
		在多的一方添加外键，指向另一方的主键。

多对多
	建表原则
		建立一张中间表，中间表至少有两个字段，这些字段作为第三张表的外键分别指向另外两张表的主键
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="多表查询">多表查询</h3>
<pre tabindex="0"><code>交叉查询 (笛卡尔积，第一张表的每一行均依次与第二张表的每一行组合)
	select * from 表A,表B
	如A={a，b} B={1，2，3}
	AxB={a1，a2，a3, b1, b2, b3} BXA顺序可能变化，但是
内连接查询
	隐式内连接
	select * from A,B where A.字段=B.字段
	显示内连接
	[inner] join 
	select * from A inner join B on A.字段=B.字段
	根据两表中字段值相同进行连接，这种查询查的其实是两表的交集
	
外连接查询
	左外连接查询 左边表的全部和两张表的交集
	select * from A left outer join B on A.字段=B.字段
	右外连接 右边表的全部和两张表的交集
	select * from A left outer join B on A.字段=B.字段
	外连接查询的是交集和补集，没有匹配的内容会返回空
	
子查询
	查询的结果可以作为条件来查询，B可以是A
	单行单列的用=
	select * from A where A.字段=(select B.字段 from B where) 
	多行多列的用 in any all
    in，在范围内的值，为true则返回
    any ，与范围内的任一值比较，为true则返回true
    all，与所有值比较，为true则返回true
    
    exisits 只要子查询的有结果，就会执行前面的查询
    select * from A where exisits (select * from B where)
    
    子查询可以作为一张虚拟的表来进行查询，注意给子查询的那张虚拟表起个别名
    select * from (select ...)
    
自连接
	select * from A a1,A a2 where a1. =a2.
	select * from A a1 left join A a2 where...
	将一张表看成两张表进行查询

99%以上都是内连接查询
	1.要查询哪些字段
	2.要用到哪些表
	3.这些表之间的关联关系。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="node">Node</h2>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="概述">概述</h3>
<pre tabindex="0"><code>运行在服务端的JavaScript，是一个基于Chrome V8引擎的JavaScript 代码运行环境
V8引擎执行JavaScript 的速度非常快，性能非常好。
V8引擎是一种js引擎的实现，js引擎是执行js代码的程序或者解释器，主要用于解析和执行js代码
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="作用-2">作用</h4>
<pre tabindex="0"><code>1.提供了js运行环境(提供了很多内置模块，保证了代码的执行)
2.可以通过js开发后台(早期的一种方式，成本比较低)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="组成">组成</h4>
<pre tabindex="0"><code>ECMAScript
	和js中的基础语法是一样的
内置模块
	fs 文件相关
	path 路径相关
	http 服务器相关
第三方模块
	express 路由，可以快速构建web应用
	mysql 可以通过js代码操作我们的数据库
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="学习路径">学习路径</h4>
<pre tabindex="0"><code>js
	js 基础语法+DOM+BOB+jquery
node.js
	js基础语法+内置模块(fs,path,http)+第三方模块(express,mysql)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="模块化">模块化</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="模块化概念">模块化概念</h4>
<pre tabindex="0"><code>概念
	遵循固定的规则，把一个大文件，拆成独立并且相互依赖的多个小模块(把代码进行模块化拆分)，也是一个封装的思想，都是对代码的封装。
	函数和方法，只能在当前文件中使用，模块还能够跨文件使用后。
	可以将一些代码放在一个单��的js文件里，就可以实现跨文件使用，这就是模块化的思想。
好处
	提高代码的复用性
	提高代码的可维护性
	可以实现按需加载
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="模块化分类">模块化分类</h4>
<pre tabindex="0"><code>根据模块的来源分类
	内置模块
		由node.js官方提供，如 fs，path，http等
	自定义模块
		用自己创建的每一个js文件，都是自定义的
	第三方模块
		由第三方开发出来的，非官方，非自定义，使用前要下载。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="模块化使用">模块化使用</h4>
<pre tabindex="0"><code>1.写一个js文件
	就是创建了一个自定义模块
2.加载模块
	require(路径)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="模块化作用域">模块化作用域</h4>
<pre tabindex="0"><code>概念
	自定义模块定义的变量，方法，只能在当前模块使用
作用
	防止了全局变量污染问题
全局变量污染问题
	模块A: let u=&#39;11&#39;
	模块B: let u=&#39;22&#39;
	此时在html页面通过script引入这两个文件，就会出现重复定义的问题。 就出现了全局变量的污染问题。
	
模块化规范
	规定模块必须先导出，引入模块必须要接收，接收的时候，就会使用不同的变量来接收，就会解决了模块中全局变量污染问题。
	A: module.exports.u=u
	B: module.exports.u=u
	
	引入模块
		const u1=require(A)
		const u2=require(B)
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="模块间共享">模块间共享</h4>
<pre tabindex="0"><code>module对象
	在每一个js自定义的模块中，都有一个module对象，存储了当前模块的相关信息。
	exports:{}，//默认情况下为空
module.exports对象
	在自定义模块中，用于将mdule.exports对象的成员共享出去，供外界使用。
	require()返回的就是共享的对象
	共享的是module.exports对象指向的对象。
exports对象
	是对module.exports的简化，默认两者是指向相同的对象
	
module.exports 对象和exports对象混合使用，可能会出现问题
	注意: reqiure()导入模块，永远会导入module.exports指向的对象(exports只是指向了这个对象而已)，当修改exports的指向的时候(给exports赋值一个对象)，不会改变module.exports的指向，只是给指向的对象添加成员不会影响指向。 反过来也是一样。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="内置模块">内置模块</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="fs模块">fs模块</h4>
<pre tabindex="0"><code>概念
	官方提供的用来操作文件的模块，提供了一系列操作文件的方法和属性，方便用户对文件进行读写。

使用 
	1.导入
		const fs=require(&#39;fs&#39;)
	2.调用方法--异步的方法，比同步而言，速度快，性能高，没有堵塞，同步方法是再方法名后面多了个Sync后缀。
		fs.readFile()
		fs.writeFile() 向指向的文件中写入数据
		
语法
	
	fs.readFile(path [,options], callback)
		path:文件路径
		option 编码等一些操作，可选参数
		callback 回调函数，读取完之后再调用的参数
		
	fs.writeFile(file,data[,option],callback)
		file: 必选参数,要读的文件
		data: 可选参数，包含编码之类的
		callback: 回调函数，写完后进行调用
	The &#34;data&#34; argument must be of type string or an instance of Buffer, TypedArray, or DataView.
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="path模块">path模块</h4>
<pre tabindex="0"><code>概念
	用于处理路径的模块，提供了处理文件和目录的实用工具
方法
	path.dirname(path) 返回目录
	path.join(目录,相对路径) 拼接路径
	path.extname(path) 返回当前文件扩展名
	path.basename(path[,ext]) 返回文件名，加第二个参数就去掉扩展名。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="http模块">http模块</h4>
<pre tabindex="0"><code>概念
	http 模块主要用于搭建HTTP 服务端和客户端
	使用http服务器或客户端功能必须调用http模块

服务器
	其实就是一台高性能的电脑，可以24小时不间断运行，对外提供服务
	装了mysql软件，数据库服务器
	装了web软件，web服务器
	一般一台电脑是一台服务器，其只具备一个专门的功能模块，如存放数据，或者web响应

我们通过http模块，使用简单代码，就能轻松搭建一个服务器软件，从而对外提供服务。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="回顾总结">回顾总结</h4>
<pre tabindex="0"><code>node.js
	概念
		提供了js代码的运行环境
		可以使用它来开发后台
	组成
		ECMAScript
		内置模块
		第三方模块
模块化编程
	概念
		按照固定的规则，把一个大的js文件拆分成若干个小文件(模块)
	好处
		提高了代码的复用性，可维护性，按需加载，便于协同开发
	导入
		require()--如果要导入同目录下的js文件，module，要加./，不能直接写名字，否则会被认为是一个包，会自动去node_modules下寻找。
	导出
		module.exports -- 导出的永远是module.exports指向的对象
分类
	内置模块
		fs，path，http
	自定义模块
		自己创建的js文件
	第三方模块
		第三方开发出来的，用之前要下载
作用域
	模块中的成员，只能在当前模块内部访问，如果想要在外部使用，需要进行导出

共享问题
	使用module.exports和exports都可以进行导出
	require() 引入的永远是module.exports指向的对象
	在一个模块中，不建议混用，习惯使用module.exports
	
内置模块
	fs
		作用
			处理文件
		方法
			readFile
			writeFile
	path
		作用
			处理路径
		方法
			dirname()
			join()
			extname()
			basename()
	http模块
		作用
			搭建web服务器
		方法
			createServer
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="package">package</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="包的概念">包的概念</h4>
<pre tabindex="0"><code>来源
	跟内置模块和自定义模块不同，是由第三方个人或者是团队开发出来的，免费给其他人使用
好处
	包其实是基于内置模块封装出来的，提供了一个更高级，更方便的API，提高了开发效率。
	包和内置的关系，类似jquery和js之间的关系
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="npm包管理工具">npm包管理工具</h4>
<pre tabindex="0"><code>概念
	是由美国的一家公司提供的，用来管理包的现在已经集成到node.js中
安装
	无需安装，在安装node的时候，已经自动安装了
查看版本
	cmd  中输入 npm -v
安装第三方包
	npm i 包名
移除包
	npm uninstall 包名
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="npm镜像管理工具">npm镜像管理工具</h4>
<pre tabindex="0"><code>淘宝NPM镜像服务器
	淘宝在国内搭建了一个服务器，专门把国外服务器上的包同步到了国内的服务器，在国内提供下包的服务，极大提高了下包的速度。

镜像
	是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像

使用
	npm install nrm -g 安装镜像管理工具
	nrm ls 列出所有的镜像
	nrm use tabao 使用淘宝的镜像
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="package-规范">package 规范</h4>
<pre tabindex="0"><code>组成
	node-modules
		用来存放所有已经安装到本地的包，require导入第三方包的时候，都是从这个目录去查找。
		&gt;jquery 
			&gt;package.json 当前包的配置文件
				name:包名
				main:包的入口(接口)
				version:版本
				description:描述
				...
		&gt;module2
			&gt;package.json
			&gt;...
规范
	1.包的顶级目录下必须包含package.json配置文件
	2.包必须以单独的目录存储
	3.package.json中必须包含name，version，main三个属性

写一个包
	1.创建文件夹
		在node-modules下创建一个calc文件夹
	2.初始化文件夹
		cd 进入这个文件夹
		使用 npm init -y来初始化这个包，会在calc下创建一个package.json，-y表示所有的都是默认状态，即确认，否则要逐个确认创建的内容
	3.创建包的目录结构
		创建src文件夹，用于存放源码
		创建dist文件夹，用于发布目录，存放最终的发布版本。
		在dist文件夹下，创建一个index.js文件，就是程序入口文件
		修改package.json配置文件中的main属性，为&#39;dist/index&#39;(相当于其他语言中的main方法，是程序的入口)
	4.在src下创建编写源码，此处实例为计算器函数，例如编写加减法文件
		如在src下创建一个add.js实现加法，并导出
		在src下创建一个sub.js实现减法，并导出。
	5.编写头文件(dist文件夹下的index.js)
		将源码里面的文件都导进去，然后用module.exports导出，将来就只需要引入头文件，就可以将所有源码文件导入
	6.使用，导入第三方包require(package) 会自动跳转到入口文件(头文件)，得到头文件的导出结果。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="package的加载机制">package的加载机制</h4>
<pre tabindex="0"><code>加载步骤
	1.node.js会假设它是一个核心模块(内置模块)
	2.如果不是内置模块，就会去当前目录下的node_modules文件夹下
	3.先找require(模块名) 同名的.js文件有就加载
	4.如果没有该名字的文件，就看是否有该名字的文件夹
	5.查看该文件夹中的package.json中的main属性，确定模块的入口文件
	6.如果进入文件夹后，没有package.json，就会默认在当前目录下加载index.js文件(或者index.node，index.json，不会进入这级目录的子目录去找)
	7.如果进入文件夹后，既没有package.json文件，也没有index.js，就会报错。

加载注意
	1.模块在第一次加载后会被缓存，也就是多次调用require()，不会导致模块被加载多次。
	2.不管是那种模块，都是优先从缓存中加载，从而提高加载速度
	3.内置模块是由node.js官方提供的，加载优先级高

加载的一般规则
	先内置模块--再到node_modules中找，.js文件---再到main指定的文件---该名字的文件夹下的index.js文件
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="客户端与服务器">客户端与服务器</h3>
<pre tabindex="0"><code>服务器
	上网过程中，负责存放和对外提供资源的电脑叫做服务器。本质就是一台电脑。
客户端
	用于获取服务器提供的资源或者消费资源的电脑。

网络通讯的三要素
	ip:设备在网络中的唯一标识
	端口:程序在设备中的唯一标识
	协议:规定了浏览器和服务器之间数据的一个传输形式
		浏览器发送什么样的数据，服务器才能解析
		服务器发什么样的数据给浏览器，浏览器才能解析
客户端与服务端的通信过程
	客户端请求服务器，服务器处理这次请求，服务器响应客户端(如客户端请求的是数据，服务器处理后就把相应数据发送给客户端)
	
服务器提供的资源
	文字图片音视频等媒体资源，数据也是一种资源
	
所谓的客户端和服务端只是电脑上的一个程序，所以一台电脑上可以有客户端也可以有服务端。vscode 的rest client插件就是客户端，liveserver插件就是一个服务端
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="url地址">url地址</h3>
<pre tabindex="0"><code>概念
	统一资源定位符，可以标识互联网上唯一一个资源(存放位置，在哪个设备上，哪个文件夹里)
	https://item.jd.com/10002.html
组成
	通讯协议:https://
	ip或者域名: item.jd.com(域名会被DNS服务器解析为一个ip地址)
	端口:一般网站默认使用的是80端口，80可省略。
	资源的名字，存放位置
	//http://localhost:8080/student.html

域名与ip的关系
	ip虽能够标识唯一一台设备，但不方便记忆，于是出现了域名，域名与ip是一一对应的，这个对应关系存放在域名服务器，DNS(Domain name server)
端口号
	每个web服务，都有唯一一个端口，客户端的请求可以通过端口交给特定的程序。
域名:IP地址的别名，localhost是一个域名，代表的ip地址为127.0.0.1，是本地的回环地址，也就是自己的电脑的ip地址，

localhost:5500是vscode的程序占用的端口，在哪个目录下启动liveserver，这个目录就会作为网站的根目录
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="http协议">HTTP协议</h3>
<pre tabindex="0"><code>通信的概念
	信息的传递和交换
通信的三要素
	通信的主体
	通信的内容
	通信的方式
通信协议
	指通信的双方完成通信所必须遵守的规则和约定。(如用事先约定好的通信格式来通信),互联网中常用的通信协议就是HTTP协议

HTTP协议(超文本传输协议) 80 TCP协议80端口
	规定了客户端与服务器传输数据的内容的格式。
	特点
		基于请求响应模型的必须先有请求再先有响应。请求响应是成对出现的，请求成功是200，失败是404，500
	以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。
HTTPS 超文本传输安全协议 443 TCP协议443端口
	HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。
请求消息
	概念
		客户端发给服务器的消息，告诉当前浏览器的一些信息
	组成
		请求行，请求头部，空行(分隔请求头和请求体)，请求体
		请求行: 请求方式 请求URI(统一资源标识符) 版本协议
		请求头: 是一系列键值对，告诉服务器我浏览器的信息
			Host:本地主机的IP地址加端口号
			user-Agent:浏览器的版本型号，服务器可以根据它来进行适配
			Accept:客户端能接收的数据格式
			Accept-Language:客户端能接收的语言
			Accept-Encoding:我能接收的编码
			Connection:连接状态 (HTTP1.1新增的)
			Referer: 网页的来源
			...
		请求体只在post请求中有
get与post的区别
	在于，get将请求数据存放在了请求行的请求URI里，也就是拼接到了地址栏，post的请求行没有请求URI，将请求数据放到了请求体里。
响应消息
	概念:
		服务器发给浏览器的信息，告诉浏览器我发给你的数据的类型特点。
	响应行: 版本协议 响应状态码 状态码描述
		   HTTP/1.1 200 OK
	响应头: 一些列键值对，告诉浏览器我服务器的信息
		Content-Type: 发送数据的格式和编码
		Access-Control-Allow-Origin:处理跨域请求
		Date:响应时间
		Connection:连接状态
		Keep-Alive:超时时长
		Content-Length:响应的字节数
	响应体 将来展示在页面正文里

restful 风格(网络应用中，资源定位和资源操作的风格)，不同请求间的作用
	get 查询 资源
	post 新建 资源
	put 修改 资源
	delete 删除 资源

常见响应状态码
	2xx 成功 200请求成功 201已创建
	3xx 重定向 302 临时移动 301 永久移动 304 未修改
	4xx 客户端错误 404 服务端无法根据客户端的请求找到资源408 请求超时 400 请求参数有误或者语义有误 401请求需要用户验证 
	5xx 服务端错误 500服务器内部错误，无法完成请求 501 服务器不支持该请求方法 503 由于超载或系统维护，服务器暂时无法处理客户端请求
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="请求响应对象">请求响应对象</h4>
<pre tabindex="0"><code>由于请求消息和响应消息都是一些字符串，想要操作非常不方便，所以node.js将其进行了封装。

请求消息封装成request对象，常写为req，一般用于获取请求数据
响应消息封装成response对象，常写为res，一般用于设置响应数据

因为请求消息是浏览器写给服务器的，一般用它来获取数据，获取请求方式，请求体等。
响应消息用来设置数据，设置响应编码
	获取请求方式 req.method
	获取请求url req.url
	设置编码方式 res.setHeader()
	设置响应体 res.send()
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="手写web服务器">手写web服务器</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="1基本的web服务">1.基本的web服务</h4>
<pre tabindex="0"><code>1.导入http模块
2.创建web服务实例
3.处理用户的请求
4.监听端口

vscode上 ctrl+c终端可以停止web服务
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">//1. 导入http模块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">http</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#34;http&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//2. 创建web服务器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">server</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">createServer</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//3. 处理用户请求（为服务器绑定一个request事件，监听客户端发来的请求，做出响应）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#34;request&#34;</span>, (<span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">res</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//req请求对象 res响应对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//程序员可以在函数体中操作 拿到的请求对象和响应对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">setHeader</span>(<span style="color:#e6db74">&#34;content-type&#34;</span>, <span style="color:#e6db74">&#34;text/html;charset=utf-8&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">end</span>(<span style="color:#e6db74">&#34;&lt;h1&gt;hello中文&lt;/h1&gt;&lt;hr&gt;&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#75715e">//4. 监听端口（发送请求所用端口需要与此一致）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">listen</span>(<span style="color:#ae81ff">3000</span>, <span style="color:#66d9ef">function</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;服务器已经启动，访问：http://127.0.0.1:3000&#34;</span>);
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="2解决中文乱码的问题">2.解决中文乱码的问题</h4>
<pre tabindex="0"><code>乱码的根源
	前后编码不一致
		服务器发送数据，默认使用ISO-8859-1，不支持中文
		浏览器接收解析数据，中文的windows使用GBK，国标
	解决:
		使用响应对象，设置一个响应头
		res.setHeader(&#39;content-type&#39;,&#39;text/html;charset=utf-8&#39;),意思是，浏览器发送数据采用utf-8编码。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="3根据不同的url响应不同的内容">3.根据不同的url响应不同的内容</h4>
<pre tabindex="0"><code>请求url默认情况在端口号后会有一个/，我们通过url访问的是设备上的不同的端口对应的程序，这些程序来回应我们的请求，如果没有程序监听该端口，就不会有响应内容。

思路
	1.先通过请求对象req获取url
	2.再通过url内置模块 url.parse(req.url,true/false)解析url，得到url对象，第二个参数推荐使用true。
	Url {
      protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: null,
      query: [Object: null prototype] {},//true为json对象，false为字符串
      pathname: &#39;/detail&#39;,
      path: &#39;/detail&#39;,
      href: &#39;/detail&#39;
    }
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="4处理get请求参数">4.处理get请求参数</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="5处理post请求参数">5.处理post请求参数</h4>
<pre tabindex="0"><code>需求:浏览器发送的请求是 http://127.0.0.1:3000/ post请求
	请求体里面数据 username=zs&amp;pwd=123
	如何拿到username和pwd的值
		思路
			判断url的路径是不是/
			判断是不是post 通过req获取请求方式
			获取数据，监听data事件和end事件
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="6封装post请求">6.封装post请求</h4>
<pre tabindex="0"><code>思路
	写一个方法，方法返回一个promise对象
	把封装的代码，放到promise对象的参数函数里
	将post请求数据放到promise的结果也就是resolve中
	调用封装的方法就可以得到promise对象，再使用该promise对象的then方法获得post请求数据
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="7处理静态资源">7.处理静态资源</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="nodemon使用">nodemon使用</h3>
<pre tabindex="0"><code>1.之前使用node运行程序，如果文件更改了，都要重启一下效率较低。
2.使用modemon，相当于node的升级版，随时监控文件的变更，自动重启服务，提高效率

使用
	npm i nodemon -g      全局安装nodemon
	nodemon 文件路径      重启服务
</code></pre><p>1.监听客户端发来的请求</p>
<p>2.一旦有请求发过来，就会触发resquest事件，执行后面的函数</p>
<p>3.服务器会为这次请求，创建请求对象req和响应对象res，req中封装了请求消息和用户提交过来的数据(detail?id=1  ?分隔的是提交的数据例如 /?username=&hellip;&amp;&amp;pwd=&hellip;)，进行处理，通过响应对象res，设置到响应消息中，最后发给浏览器。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="静态页面">静态页面</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="json-server">json-server</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="跨域请求">跨域请求</h3>
<pre tabindex="0"><code>浏览器向 liveserver 请求页面
live server 响应页面给浏览器
浏览器解析页面的内容，由于页面内有代码向其他服务端请求如json-server请求数据
json-server响应数据给浏览器

跨域问题只会在浏览器中发生，产生的原因是什么，什么叫跨域，为什么叫跨域，是怎么解决的
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="昨日回顾">昨日回顾</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>接口编程
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RESTful 
</span></span><span style="display:flex;"><span>  概念
</span></span><span style="display:flex;"><span>    一种接口的设计风格，主要用于前后端交互的软件
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  六要素：请求路径url，请求方法req.method，请求参数req.querystring，响应状态码，响应参数，响应数据
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RESTful接口体验
</span></span><span style="display:flex;"><span>  服务端(使用data.json作为数据源)
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="jquery的ajax">jquery的ajax</h4>
<p>$.ajax() 通用格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">ajax</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">url</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#39;&#39;</span>,<span style="color:#75715e">//请求路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#39;GET&#39;</span>,<span style="color:#75715e">//请求方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">data</span><span style="color:#f92672">:</span>{},<span style="color:#75715e">//请求参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dataType</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#39;&#39;</span>,<span style="color:#75715e">//返回数据的格式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">success</span><span style="color:#f92672">:</span><span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">res</span>){},
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">error</span><span style="color:#f92672">:</span><span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">res</span>){},
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>GET请求专用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">url</span>,[<span style="color:#a6e22e">data</span>],[<span style="color:#a6e22e">callback</span>],[<span style="color:#a6e22e">type</span>])
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  url:请求路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  data:请求参数 key:value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  callback:成功时的回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  type:返回内容的格式，xml，html，script，json，text，_default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">post</span>(<span style="color:#a6e22e">url</span>,[<span style="color:#a6e22e">data</span>],[<span style="color:#a6e22e">callback</span>],[<span style="color:#a6e22e">type</span>])
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="express">Express</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="简介-1">简介</h4>
<p>是什么？是一个简洁而灵活的 node.js web应用框架，提供了一系列强大特性帮助你创建各种web应用，帮助你创建各种web应用，和丰富的HTTP工具。使用EXpress可以快速搭建一个完整功能的网站
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="本质">本质</h4>
<p>对http模块做了一些封装
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="核心特性">核心特性</h4>
<p>可以设置中间件来响应Http请求<!-- raw HTML omitted -->定义了路由表用于执行不同的HTTP请求动作
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="相关概念">相关概念</h4>
<p>路由: 根据不同请求方式的url路径，调用后台不同的处理函数，这些url就是路由，因此路由可以认为是依据不同请求方式找到不同资源的路径。<!-- raw HTML omitted -->路由的匹配过程：<!-- raw HTML omitted -->每个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后才会调用相应方法。<!-- raw HTML omitted -->中间件：指从请求到响应业务流程中所有的中间流程
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="安装即使用">安装即使用</h4>
<p>安装<!-- raw HTML omitted -->要英文目录，先初始化<code>npm init -y</code>，再安装<code>npm i express</code><!-- raw HTML omitted -->使用</p>
<ol>
<li>导入express包</li>
<li>实例化express对象</li>
<li>处理请求</li>
</ol>
<p><code>app.verb('path',(req,res)=&gt;{})</code><!-- raw HTML omitted --><code>app.verb('path:',(req,res)=&gt;{})</code></p>
<ol start="4">
<li>监听端口</li>
</ol>
<p>与原生的http手写服务的区别</p>
<ol>
<li>不用处理乱码问题</li>
<li>不用判断请求方式特定请求方式有特定的方法
<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
<h4 id="路由的定义规则">路由的定义规则</h4>
<p>app.verb(path,callback)</p>
<ol>
<li>verb表示请求方式，http动词，可以是<code>get post put delete</code>常用前两个</li>
<li>path表示访问的路径，基准地址后的路径用于标识基准地址设备上的资源的位置，一般为字符串，也可以是正则表达式</li>
</ol>
<p>有三种写法:</p>
<pre><code>  1. `/path/:id` 带参数，此处的id指向的是path指向的资源里id为当前参数的数据
  2. `/path` 不带参数 参数的获取通过req.params
  3. `/.html$/`
</code></pre>
<ol start="3">
<li>callback，路径处理函数，对不同的路径，调用不同的方法处理。</li>
</ol>
<p>注意事项</p>
<ol>
<li>匹配的时候，按照顺序从上到下匹配，当匹配成功后就不会再执行下面的。</li>
<li>只有请求的类型和url同时匹配成功，express才会将这次请求提交到对应的处理函数</li>
</ol>
<p>res.send()和res.end()的区别<!-- raw HTML omitted -->end只能响应字符串，并且不能处理乱码问题<!-- raw HTML omitted -->send:可以响应任意类型的数据，如json，xml，字符串等，并且可以处理乱码问题</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="express响应静态资源">express响应静态资源</h4>
<ol>
<li>获取静态资源的路劲</li>
<li>调用res.sendFile(path,callback)</li>
</ol>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="express增删改查">express增删改查</h4>
<ol>
<li>查</li>
</ol>
<p><code>get</code></p>
<ol start="2">
<li>增</li>
</ol>
<p><code>post</code></p>
<ol start="3">
<li>改</li>
</ol>
<p><code>put</code></p>
<ol start="4">
<li>删</li>
</ol>
<p><code>delete</code>
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="注意事项">注意事项</h4>
<p>非js文件或JavaScript语法下，json对象里的属性和属性值要加且只能加双引号，且最后一个键值对后不能加&quot;，&ldquo;号
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="可迭代对象的遍历">可迭代对象的遍历</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">iterable</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">item</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">index</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>)<span style="color:#75715e">//item形参接收的数据为迭代对象的每一个子元素，如数组的每一项		 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>})
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="nodejs-获取请求中的数据">node.js 获取请求中的数据</h3>
<ol>
<li>获取<code>get</code>数据</li>
</ol>
<p>利用<code>url</code>模块的<code>parse</code>方法解析<code>req.url</code>，<code>req.url</code>是请求url的路径如<code>/detail?id=1</code>，<code>url.parse</code>，可以将完整的url解析为很多部分，如<code>host、port、pathname、path、query等</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">//导入url模块
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">url</span><span style="color:#f92672">=</span><span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;url&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> {<span style="color:#a6e22e">pathname</span>,<span style="color:#a6e22e">query</span>} <span style="color:#f92672">=</span> <span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">url</span>)<span style="color:#75715e">//得到的是一个url对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//pathname 为资源路径，query为json对象如{id:1}
</span></span></span></code></pre></div><ol start="2">
<li>获取<code>post</code>数据</li>
</ol>
<p>post数据数据量一般较大，因此采用异步方式传输和获取客户端提交给服务端的请求体中的数据。分为两部分，接收客户端提交的一段段数据到达的data事件，<code>req.on('data',callback(data){})</code>，回调函数的<code>data</code>参数为当前提交的这一段数据，数据传输均以字节流形式传输；以及数据传输完成后的end事件<code>req.on('end',callback(){//数据全部到达时执行})</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">postData</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;data&#39;</span>,(<span style="color:#a6e22e">data</span>)=&gt;<span style="color:#a6e22e">postData</span><span style="color:#f92672">+=</span><span style="color:#a6e22e">data</span>)<span style="color:#75715e">//这里其实将字节流buffer对象转为了字符串，最终结果为json字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;end&#39;</span>,()=&gt;{<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;数据传输完成&#39;</span>)})
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="关于buffer对象和string之间的转换">关于Buffer对象和string之间的转换</h3>
<ul>
<li>buffer-&gt;string		<code>buffer.tostring([encoding], [start], [end])</code>默认为utf-8编码。</li>
<li>string-&gt;buffer		<code>buf.write(string, [offset], [length], [encoding])</code>向已创建的buffer对象写入字符串</li>
</ul>
<p>
  <p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29064333/1653617116628-59889ccc-0098-4a9c-8011-72dbfdc227b1.jpeg" alt="" loading="lazy" /></p>
<!-- raw HTML omitted -->
  <p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29064333/1653618160519-4a21d7a1-a1c0-44b9-ba25-b4b8db55f9fb.jpeg" alt="" loading="lazy" /></p>

<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="中间件函数">中间件函数</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="概念middleware">概念(middleware)</h4>
<p>特指业务流程的中间处理环节，本质是一个函数。中间件其实也是一个路由
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="调用流程">调用流程</h4>
<p>当一个express服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="分类">分类</h4>
<p>全局中间件<!-- raw HTML omitted -->局部中间件
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="注意-1">注意</h4>
<p>中间件函数的形参列表中必须包含next参数，之前的路由处理函数只包含<code>req，res</code>。<!-- raw HTML omitted -->next函数的作用：实现多个中间件连续调用的关键，表示把流程转交到下一个中间件或者处理函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">middleware1</span>(<span style="color:#a6e22e">req</span>,<span style="color:#a6e22e">res</span>,<span style="color:#a6e22e">next</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">postData</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;data&#39;</span>,<span style="color:#a6e22e">data</span>=&gt;<span style="color:#a6e22e">postData</span><span style="color:#f92672">+=</span><span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;end&#39;</span>,<span style="color:#66d9ef">function</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">body</span><span style="color:#f92672">=</span><span style="color:#a6e22e">postData</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">next</span>()<span style="color:#75715e">//next()代表后续中间件或者流程要执行的内容，是中间件必不可少的内容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="局部生效的中间件">局部生效的中间件</h4>
<p>概念<!-- raw HTML omitted -->只在某些访问路径中使用的中间件，叫做局部生效的中间件<!-- raw HTML omitted -->举例<!-- raw HTML omitted --><code>getPostData</code>，只在新增和修改的路由中生效，就是局部生效的中间件<!-- raw HTML omitted -->注意</p>
<ol>
<li>一定要在路由之前注册中间件</li>
<li>客户端发送过来的请求，可以连续调用多个中间件处理</li>
<li>执行完中间件的业务代码，要调用<code>next</code>将流程转向下个中间件</li>
<li><code>next()</code>后面尽量不要写额外代码，防止逻辑混乱</li>
<li>多个连续调用的中间件可以共享req和res对象</li>
</ol>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="全局生效的中间件">全局生效的中间件</h4>
<p>概念<!-- raw HTML omitted -->客户端发起任何请求，到达服务端都会触发的中间件<!-- raw HTML omitted -->使用<!-- raw HTML omitted -->通常使用<code>app.use(中间件函数)</code>，来定义一个全局的中间件。<!-- raw HTML omitted -->注意事项</p>
<ol>
<li>全局中间件的执行顺序，一般是先定义的先执行，全局执行完再执行局部的</li>
<li>由于路由都是异步的，全局定义在路由前后，路由匹配成功后都可以使用该中间件。</li>
</ol>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="内置中间件">内置中间件</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="概念-3">概念</h5>
<p>由<code>express</code>官方提供的，主要有3个常见的内置中间件：<!-- raw HTML omitted --><code>express.static</code><!-- raw HTML omitted -->快速托管静态资源的内置中间件，可以加载html文件，图片，css样式等。<!-- raw HTML omitted --><code>express.json</code><!-- raw HTML omitted -->解析json格式的请求体<!-- raw HTML omitted --><code>express.urlencded</code><!-- raw HTML omitted -->解析url-encode格式的请求体，如<code>name=xiaoting&amp;age=27</code>，表单数据就是按照这样的格式提交的</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="应用级中间件">应用级中间件</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="概念-4">概念</h5>
<p>通过<code>app.use()</code>，和<code>app.verb</code>绑定到<code>app</code>上的中间件
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="注意-2">注意</h5>
<p>应用级中间件，可以是全局生效的，也可以是局部生效的，只不过都要绑定到app上</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="模块化路由">模块化路由</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="由来">由来</h5>
<ol>
<li>当路由很多的话，如果全部写在<code>app</code>入口文件，文件就太大了，不好维护</li>
<li>项目中有不同类型的请求路径，用户相关的，商品相关的，都放在一个文件里也不好维护</li>
<li>为了方便路由进行模块化管理，<code>express</code>不建议路由直接挂载到<code>app</code>上而是推荐将路由抽离成单独的模块
<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
<h5 id="步骤">步骤</h5>
<ol>
<li>创建路由模块对应的js文件，放在routes文件夹下</li>
<li>调用<code>express.router()</code>创建路由对象</li>
<li>向路由对象挂载具体的路由</li>
<li>使用<code>module.exports</code>向外共享路由</li>
<li>在要使用路由的入口文件中，用<code>app.use()</code>注册路由</li>
</ol>
<p>本质上是对实体分类进行了路由的分发。<!-- raw HTML omitted -->
  <p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29064333/1653634421077-fc770628-85b5-4729-a5e4-8a68bbba927f.jpeg" alt="" loading="lazy" /></p>
</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="路由级中间件">路由级中间件</h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="概念-5">概念</h5>
<p>绑定在路由对象上的中间件<!-- raw HTML omitted -->
  <p><img src="https://cdn.nlark.com/yuque/0/2022/png/29064333/1653635985155-5fcf1b22-472b-432f-9f73-a95f31ad3d6f.png#averageHue=%2323201f&amp;clientId=u0052a44b-49b9-4&amp;from=paste&amp;height=56&amp;id=u80c4d40d&amp;originHeight=70&amp;originWidth=442&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7256&amp;status=done&amp;style=none&amp;taskId=u335cb826-3c13-43fc-81a3-7caec1f9029&amp;title=&amp;width=353.6" alt="image.png" loading="lazy" /></p>

<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="注意-3">注意</h5>
<p>路由级中间件用处不是特别多，更多的是全局中间件。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="node连接数据库">node连接数据库</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="步骤-1">步骤</h4>
<ol>
<li>下载mysql包 <code>npm i mysql</code></li>
<li>导入MySQL <code>const mysql=require('mysql')</code></li>
<li>创建连接  <code>const con=mysql.createConnection({host,port,user,password,database})</code></li>
<li>连接数据库 <code>con.connect()</code></li>
<li>执行sql语句 <code>con.query(sql)</code></li>
<li>关闭连接  <code>con.end()</code></li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>在进行sql语句的编写的时候，sql语句是一个字符串，去掉外面的引号后的语句才是sql语句，此时如果里面有字符型的需要用<code>''</code>括起来，否则会报错。也就是说要保证sql字符串去掉外面的引号后能运行才行。因此推荐使用占位符的形式写sql。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">con</span>.<span style="color:#a6e22e">query</span>(<span style="color:#e6db74">&#34;select * from users where username=? and pwd=?&#34;</span>, [<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">username</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">pwd</span>], <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">data</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">err</span>) <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;404 not found 用户密码错误&#39;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">result</span>)
</span></span><span style="display:flex;"><span>    })
</span></span></code></pre></div>
          </div>
        </div>
                 
      
  
  
  
  

  

  <div class="article-paging">
    
      <section class="post-paging--item card-container content-padding-primary soft-size--primary soft-style--box">
  <div class="card-cover" background-image-lazy data-img="https://cdn.nlark.com/yuque/0/2022/png/29064333/1653488075701-541d53ef-24ad-44a1-b410-e9cb98f4d851.png"></div>
  <div class="card-text">
    <a href="/docs/aya402/"><h4 class="card-text--title text-ellipsis">跨域请求</h4></a>
    <p class="card-text--row">2022-05-25 13:44</p>
  </div>
</section>
    
    
  </div>
</div>
  <aside class="widget-info">
    
<section class="aside-widget widget-author content-padding-large soft-size--large soft-style--box">
  <div class="widget-body">
    <div class="author-box avatar">
      
      <img class="author-avatar soft-size--round soft-style--box" src="https://cdn.jsdelivr.net/gh/Sentisfate/wanhuatong@main/img/cdai.jfif" alt="gisculibur">
      
      <h2 class="author-name text-ellipsis">gisculibur</h2>
      
      <p class="author-desc text-ellipsis">新手WebGIS攻城狮</p>
      
    </div>
  </div>
</section>


    

<section class="aside-widget widget-toc content-padding-large soft-size--large soft-style--box">
  <h2 class="widget-header">
    <div class="title">
      <span>目录</span>
    </div>
  </h2>
  <div class="widget-body">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#html">HTML</a>
          <ul>
            <li><a href="#概念">概念</a></li>
            <li><a href="#操作思想">操作思想</a></li>
            <li><a href="#特点">特点</a></li>
            <li><a href="#语法">语法</a></li>
            <li><a href="#标签分类">标签分类</a></li>
            <li><a href="#常用标签">常用标签</a></li>
            <li><a href="#文本相关标签">文本相关标签</a></li>
            <li><a href="#格式相关标签">格式相关标签</a></li>
            <li><a href="#列表相关标签">列表相关标签</a></li>
            <li><a href="#行级标签">行级标签</a></li>
            <li><a href="#块级标签">块级标签</a></li>
            <li><a href="#图片媒体标签">图片媒体标签</a></li>
            <li><a href="#超链接标签">超链接标签</a></li>
            <li><a href="#布局相关标签">布局相关标签</a></li>
            <li><a href="#布局标签div">布局标签div</a></li>
            <li><a href="#表单标签">表单标签</a></li>
            <li><a href="#表格标签">表格标签</a></li>
          </ul>
        </li>
        <li><a href="#css">CSS</a>
          <ul>
            <li><a href="#概念-1">概念</a></li>
            <li><a href="#区别">区别</a></li>
            <li><a href="#css的引入方式">css的引入方式</a></li>
            <li><a href="#css三种引入的优先级">css三种引入的优先级</a></li>
            <li><a href="#css选择器分类">css选择器分类</a>
              <ul>
                <li><a href="#作用">作用：</a></li>
                <li><a href="#基本分类">基本分类：</a></li>
                <li><a href="#三种优先级">三种优先级</a></li>
                <li><a href="#拓展分类">拓展分类</a></li>
              </ul>
            </li>
            <li><a href="#emmet语法">emmet语法</a></li>
            <li><a href="#常见属性">常见属性</a></li>
            <li><a href="#字体相关属性">字体相关属性</a></li>
            <li><a href="#文本相关属性">文本相关属性</a></li>
            <li><a href="#背景相关属性">背景相关属性</a>
              <ul>
                <li><a href="#精灵图的应用">精灵图的应用</a></li>
              </ul>
            </li>
            <li><a href="#css三大特性">CSS三大特性</a></li>
            <li><a href="#盒子模型">盒子模型</a>
              <ul>
                <li><a href="#行盒块盒分类">行盒块盒分类</a></li>
              </ul>
            </li>
            <li><a href="#盒子模型的组成">盒子模型的组成</a></li>
            <li><a href="#边框详解">边框详解</a></li>
            <li><a href="#内边距">内边距</a></li>
            <li><a href="#盒子模型最终计算公式">盒子模型最终计算公式</a>
              <ul>
                <li><a href="#盒子模型的特殊情况">盒子模型的特殊情况</a></li>
              </ul>
            </li>
            <li><a href="#外边距">外边距</a>
              <ul>
                <li><a href="#外边距的正常情况">外边距的正常情况</a></li>
                <li><a href="#外边距的特殊情况">外边距的特殊情况</a></li>
                <li><a href="#外边距的塌陷上外边距">外边距的塌陷（上外边距）</a></li>
              </ul>
            </li>
            <li><a href="#清楚浏览器的默认样式">清楚浏览器的默认样式</a></li>
            <li><a href="#伪元素">伪元素</a></li>
            <li><a href="#伪类结构选择器">伪类结构选择器</a></li>
            <li><a href="#标准流">标准流</a></li>
            <li><a href="#浮动float">浮动float</a></li>
            <li><a href="#清除浮动">清除浮动</a></li>
            <li><a href="#样式书写规范">样式书写规范</a></li>
            <li><a href="#定位">定位</a>
              <ul>
                <li><a href="#简介">简介</a></li>
                <li><a href="#相对定位">相对定位</a></li>
                <li><a href="#绝对定位">绝对定位</a></li>
                <li><a href="#子绝父相">子绝父相</a></li>
                <li><a href="#固定定位">固定定位</a></li>
                <li><a href="#层级关系">层级关系</a></li>
              </ul>
            </li>
            <li><a href="#vertical-align">Vertical-align</a>
              <ul>
                <li><a href="#概念-2">概念</a></li>
                <li><a href="#作用-1">作用</a></li>
                <li><a href="#取值">取值</a></li>
                <li><a href="#应用">应用</a></li>
              </ul>
            </li>
            <li><a href="#其他效果">其他效果</a>
              <ul>
                <li><a href="#溢出效果">溢出效果</a></li>
                <li><a href="#隐藏效果">隐藏效果</a></li>
              </ul>
            </li>
            <li><a href="#字体图标">字体图标</a></li>
            <li><a href="#css新特性">css新特性</a>
              <ul>
                <li><a href="#1过渡">1.过渡</a></li>
                <li><a href="#2位移">2.位移</a></li>
                <li><a href="#3旋转">3.旋转</a></li>
                <li><a href="#4渐变">4.渐变</a></li>
                <li><a href="#5动画">5.动画</a></li>
              </ul>
            </li>
            <li><a href="#flex布局">flex布局</a>
              <ul>
                <li><a href="#flex布局的特点">flex布局的特点</a></li>
              </ul>
            </li>
            <li><a href="#浏览器调试技巧">浏览器调试技巧</a></li>
            <li><a href="#布局顺序">布局顺序</a></li>
            <li><a href="#项目前置须知">项目前置须知</a>
              <ul>
                <li><a href="#文件组成">文件组成</a></li>
                <li><a href="#网页结构">网页结构</a></li>
                <li><a href="#版心">版心</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#javascript">JavaScript</a>
          <ul>
            <li><a href="#概念及入门">概念及入门</a></li>
            <li><a href="#变量">变量</a></li>
            <li><a href="#数据类型">数据类型</a></li>
            <li><a href="#运算符">运算符</a></li>
            <li><a href="#js中的输入输出">js中的输入输出</a></li>
            <li><a href="#流程控制">流程控制</a>
              <ul>
                <li><a href="#顺序结构">顺序结构</a></li>
                <li><a href="#选择结构">选择结构</a></li>
                <li><a href="#循环结构">循环结构</a></li>
                <li><a href="#break-continue">break continue</a></li>
              </ul>
            </li>
            <li><a href="#数组">数组</a></li>
            <li><a href="#函数">函数</a></li>
            <li><a href="#面向过程">面向过程</a></li>
            <li><a href="#面向对象">面向对象</a></li>
            <li><a href="#math对象">Math对象</a></li>
            <li><a href="#date对象">Date对象</a></li>
            <li><a href="#array对象">Array对象</a></li>
            <li><a href="#string对象">String对象</a></li>
            <li><a href="#json对象">Json对象</a></li>
            <li><a href="#dom概念">DOM概念</a></li>
            <li><a href="#dom">DOM</a>
              <ul>
                <li><a href="#事件">事件</a></li>
                <li><a href="#事件对象">事件对象</a></li>
                <li><a href="#dom节点操作">DOM节点操作</a></li>
              </ul>
            </li>
            <li><a href="#bom">BOM</a></li>
            <li><a href="#jquery">JQuery</a>
              <ul>
                <li><a href="#入门案例">入门案例</a></li>
                <li><a href="#基础语法">基础语法</a></li>
                <li><a href="#jquery选择器">jquery选择器</a></li>
                <li><a href="#jquery筛选方法">jquery筛选方法</a></li>
                <li><a href="#jquery核心函数">jquery核心函数</a></li>
                <li><a href="#jquerydom操作">jqueryDOM操作</a></li>
                <li><a href="#jquery-动画">jquery 动画</a></li>
                <li><a href="#jquery-遍历">jquery 遍历</a></li>
                <li><a href="#jquery事件">jquery事件</a></li>
              </ul>
            </li>
            <li><a href="#js高级语法">js高级语法</a>
              <ul>
                <li><a href="#作用域">作用域</a></li>
                <li><a href="#全局变量的定义">全局变量的定义</a></li>
                <li><a href="#预解析">预解析</a></li>
                <li><a href="#原型和this指向">原型和this指向</a></li>
                <li><a href="#静态成员和实例成员">静态成员和实例成员</a></li>
                <li><a href="#构造函数的问题">构造函数的问题</a></li>
                <li><a href="#原型对象-prototype">原型对象 prototype</a></li>
                <li><a href="#对象原型-proto">对象原型 <strong>proto</strong></a></li>
                <li><a href="#constructor-构造器构造函数">constructor 构造器(构造函数)</a></li>
                <li><a href="#原型链">原型链</a></li>
                <li><a href="#原型对象中的this指向">原型对象中的this指向</a></li>
                <li><a href="#函数进阶">函数进阶</a></li>
                <li><a href="#let声明变量">let声明变量</a></li>
                <li><a href="#const">const</a></li>
                <li><a href="#类和继承">类和继承</a></li>
                <li><a href="#解构赋值">解构赋值</a></li>
                <li><a href="#箭头函数lambda-表达式">箭头函数(Lambda 表达式)</a></li>
                <li><a href="#promise">promise</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#mysql">MySQL</a>
          <ul>
            <li><a href="#数据库概念">数据库概念</a></li>
            <li><a href="#数据类型-1">数据类型</a>
              <ul>
                <li><a href="#整形">整形</a></li>
                <li><a href="#浮点型">浮点型</a></li>
                <li><a href="#字符型">字符型</a></li>
                <li><a href="#日期和时间类型">日期和时间类型</a></li>
              </ul>
            </li>
            <li><a href="#字段属性">字段属性</a></li>
            <li><a href="#建库操作">建库操作</a></li>
            <li><a href="#数据写操作">数据写操作</a>
              <ul>
                <li><a href="#增加-insert">增加 insert</a></li>
                <li><a href="#修改-update">修改 update</a></li>
                <li><a href="#删除记录-delete">删除记录 delete</a></li>
                <li><a href="#注意">注意</a></li>
              </ul>
            </li>
            <li><a href="#数据查询">数据查询</a></li>
            <li><a href="#单表约束">单表约束</a></li>
            <li><a href="#多表约束">多表约束</a></li>
            <li><a href="#多表关系">多表关系</a></li>
            <li><a href="#多表查询">多表查询</a></li>
          </ul>
        </li>
        <li><a href="#node">Node</a>
          <ul>
            <li><a href="#概述">概述</a>
              <ul>
                <li><a href="#作用-2">作用</a></li>
                <li><a href="#组成">组成</a></li>
                <li><a href="#学习路径">学习路径</a></li>
              </ul>
            </li>
            <li><a href="#模块化">模块化</a>
              <ul>
                <li><a href="#模块化概念">模块化概念</a></li>
                <li><a href="#模块化分类">模块化分类</a></li>
                <li><a href="#模块化使用">模块化使用</a></li>
                <li><a href="#模块化作用域">模块化作用域</a></li>
                <li><a href="#模块间共享">模块间共享</a></li>
              </ul>
            </li>
            <li><a href="#内置模块">内置模块</a>
              <ul>
                <li><a href="#fs模块">fs模块</a></li>
                <li><a href="#path模块">path模块</a></li>
                <li><a href="#http模块">http模块</a></li>
                <li><a href="#回顾总结">回顾总结</a></li>
              </ul>
            </li>
            <li><a href="#package">package</a>
              <ul>
                <li><a href="#包的概念">包的概念</a></li>
                <li><a href="#npm包管理工具">npm包管理工具</a></li>
                <li><a href="#npm镜像管理工具">npm镜像管理工具</a></li>
                <li><a href="#package-规范">package 规范</a></li>
                <li><a href="#package的加载机制">package的加载机制</a></li>
              </ul>
            </li>
            <li><a href="#客户端与服务器">客户端与服务器</a></li>
            <li><a href="#url地址">url地址</a></li>
            <li><a href="#http协议">HTTP协议</a>
              <ul>
                <li><a href="#请求响应对象">请求响应对象</a></li>
              </ul>
            </li>
            <li><a href="#手写web服务器">手写web服务器</a>
              <ul>
                <li><a href="#1基本的web服务">1.基本的web服务</a></li>
                <li><a href="#2解决中文乱码的问题">2.解决中文乱码的问题</a></li>
                <li><a href="#3根据不同的url响应不同的内容">3.根据不同的url响应不同的内容</a></li>
                <li><a href="#4处理get请求参数">4.处理get请求参数</a></li>
                <li><a href="#5处理post请求参数">5.处理post请求参数</a></li>
                <li><a href="#6封装post请求">6.封装post请求</a></li>
                <li><a href="#7处理静态资源">7.处理静态资源</a></li>
              </ul>
            </li>
            <li><a href="#nodemon使用">nodemon使用</a></li>
            <li><a href="#静态页面">静态页面</a></li>
            <li><a href="#json-server">json-server</a></li>
            <li><a href="#跨域请求">跨域请求</a></li>
            <li><a href="#昨日回顾">昨日回顾</a>
              <ul>
                <li><a href="#jquery的ajax">jquery的ajax</a></li>
              </ul>
            </li>
            <li><a href="#express">Express</a>
              <ul>
                <li><a href="#简介-1">简介</a></li>
                <li><a href="#本质">本质</a></li>
                <li><a href="#核心特性">核心特性</a></li>
                <li><a href="#相关概念">相关概念</a></li>
                <li><a href="#安装即使用">安装即使用</a></li>
                <li><a href="#路由的定义规则">路由的定义规则</a></li>
                <li><a href="#express响应静态资源">express响应静态资源</a></li>
                <li><a href="#express增删改查">express增删改查</a></li>
                <li><a href="#注意事项">注意事项</a></li>
              </ul>
            </li>
            <li><a href="#可迭代对象的遍历">可迭代对象的遍历</a></li>
            <li><a href="#nodejs-获取请求中的数据">node.js 获取请求中的数据</a></li>
            <li><a href="#关于buffer对象和string之间的转换">关于Buffer对象和string之间的转换</a></li>
            <li><a href="#中间件函数">中间件函数</a>
              <ul>
                <li><a href="#概念middleware">概念(middleware)</a></li>
                <li><a href="#调用流程">调用流程</a></li>
                <li><a href="#分类">分类</a></li>
                <li><a href="#注意-1">注意</a></li>
                <li><a href="#局部生效的中间件">局部生效的中间件</a></li>
                <li><a href="#全局生效的中间件">全局生效的中间件</a></li>
                <li><a href="#内置中间件">内置中间件</a></li>
                <li><a href="#应用级中间件">应用级中间件</a></li>
                <li><a href="#模块化路由">模块化路由</a></li>
                <li><a href="#路由级中间件">路由级中间件</a></li>
              </ul>
            </li>
            <li><a href="#node连接数据库">node连接数据库</a>
              <ul>
                <li><a href="#步骤-1">步骤</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</section>


    










<section class="aside-widget widget-articles content-padding-large soft-size--large soft-style--box">
  <h2 class="widget-header">
    <div class="title">
      <span>相关文章</span>
    </div>
  </h2>
  <div class="widget-body">
    <ul class="post-list">
      
      
        <li class="post-item"><a href="/docs/ix726493ddpi6i3q/">3dTiles</a></li>
      
        <li class="post-item"><a href="/posts/qa4vydlw37pbsi3v/">WebGL 图像处理</a></li>
      
        <li class="post-item"><a href="/docs/goz05uyu3i5v92c9/">Cesium 模型压平</a></li>
      
        <li class="post-item"><a href="/docs/cl6l0mww8kkkizwb/">三角剖分</a></li>
      
        <li class="post-item"><a href="/docs/prgrgit7lss8vggf/">GIS理论基础</a></li>
      
        <li class="post-item"><a href="/docs/vzxnspucb4agb00w/">问题</a></li>
      
    </ul>
  </div>
</section>


    




<section class="aside-widget widget-categories content-padding-large soft-size--large soft-style--box">
  <h2 class="widget-header">
    <div class="title">
      <span>分类</span>
    </div>
  </h2>
  <div class="widget-body">
    <ul class="categories-list">
      
        <li>
          <a href="https://Sentisfate.github.io/categories/webgl/">WebGL</a>
          <span>1</span>
        </li>
      
        <li>
          <a href="https://Sentisfate.github.io/categories/%E5%9B%BE%E5%BA%8A/">图床</a>
          <span>1</span>
        </li>
      
    </ul>
  </div>

  
</section>


    




<section class="aside-widget widget-tags content-padding-large soft-size--large soft-style--box">
  <h2 class="widget-header">
    <div class="title">
      <span>标签</span>
    </div>
  </h2>
  <div class="widget-body">
    <div class="tags-list">
      
        <a href="https://Sentisfate.github.io/tags/github/" data-count="1" class="soft-size--small soft-style--hover soft-style--active">github</a>
      
        <a href="https://Sentisfate.github.io/tags/picgo/" data-count="1" class="soft-size--small soft-style--hover soft-style--active">picgo</a>
      
        <a href="https://Sentisfate.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" data-count="1" class="soft-size--small soft-style--hover soft-style--active">图像处理</a>
      
    </div>
  </div>

  
</section>

  </aside>
</div>
  </main><footer class="footer-container layout-block">
  
  <div class="social-icons">
    
      <a class="soft-size--primary soft-style--box" href="https://github.com/Sentisfate" target="_blank" rel="noopener noreferrer">
          
        <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
        </svg>
        

        

        

        

        
      </a>
    
  </div>
  

  <div class="colour-bar"></div>
  
  

  

  <p>
    Powered by
    <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a>
    Theme - 
    <a href="https://github.com/miiiku/hugo-theme-kagome" target="_blank" rel="noopener noreferrer author">kagome</a>
  </p>

  <p>
    <a href="javascript:;" id="theme-light">🌞 浅色</a>
    <a href="javascript:;" id="theme-dark">🌛 深色</a>
    <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
  </p>
</footer>



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>






</body>

</html>